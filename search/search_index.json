{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Projektbeschreibung","text":""},{"location":"#dhbw-student-argere-dich-nicht","title":"DHBW \u2013 Student \u00e4rgere dich nicht","text":"<p>Dieses Projekt befasst sich mit der Wiederauferstehung eines alten Klassikers. Es geht um das alt bekannte Brettspiel \u201eMensch \u00e4rgere dich nicht\u201c. Ein Spiel, dass so ziemlich jeder zu Hause hat, vermutlich aber selten zum Einsatz kommt. Gerade bei den j\u00fcngeren Generationen fehlt einfach der Reiz, einen Spieleabend, mit einem etwas in die Jahre gekommenen Brettspiel zu verbringen. Wir von der DHBW \u2013 Spielschmiede AG, haben es uns zur Aufgabe gemacht, dieses Spiel neu aufleben zu lassen. Wir vereinigen den alten Charm des Klassikers mit moderner Technik. Ein Mikrocontroller, der den gesamten Spielablauf \u00fcbernimmt. Einzig die Spieleinstellung, das W\u00fcrfeln und die Auswahl der Figur, die bewegt werden soll, muss man selbst vornehmen. Schummeln, Meinungsverschiedenheiten oder verlorene Spielfiguren sind somit Geschichte. Auch das Spielen gegen einen Computer ist nun m\u00f6glich. All das kompakt und praktisch verstaut in einem Geh\u00e4use. </p> <p>Mit unserem Produkt schlie\u00dfen wir eine unentdeckte Marktl\u00fccke, die nun wirklich ein Spiel f\u00fcr Jung und Alt hervorbringt. </p>"},{"location":"#bedienungsanleitung","title":"Bedienungsanleitung","text":"<p>Die Bedienungsanleitung (Dokument DOC_DED_OUT_Betriebsanleitung.pdf) kann hier angesehen und heruntergeladen werden.</p>"},{"location":"#begrundung-der-hardwareauswahl","title":"Begr\u00fcndung der Hardwareauswahl:","text":"<p>Bei der Hardwareauswahl wurden zun\u00e4chst verschiedene Ans\u00e4tze f\u00fcr die Anzeige des Spielfeldes sowie die Auswahl des geeigneten Mikrocontrollers in Betracht gezogen. Es wurde sowohl eine selbstgebaute LED-Anzeige aus einzelnen Leuchtdioden, als auch eine fertige Matrix-LED in Erw\u00e4gung gezogen. Durch Recherche kristallisierten sich jedoch erhebliche Vorteile der LED-Matrix gegen\u00fcber der selbstgebauten Anzeige heraus. Das Team hat gemeinsam beschlossen, aufgrund des hohen Fertigungsaufwands und der hohen Kosten im Vergleich zu einer fertigen Matrix-Anzeige, die im Internet erh\u00e4ltlich ist, auf den eigenen Bau einer Matrix-Anzeige zu verzichten. Die Matrix-Anzeige aus dem Internet bietet zudem einige Vorteile in Bezug auf die Einfachheit der Programmierung sowie die leichte Wiederbeschaffbarkeit.</p> <p>Bei der Auswahl des Mikrocontrollers wurde zun\u00e4chst zwischen einem Arduino Mega und einem Arduino Uno geschwankt. Im weiteren Verlauf der Planung stellte sich jedoch heraus, dass der Arduino Uno nicht \u00fcber ausreichend Timer verf\u00fcgt, weshalb die Entscheidung auf den Arduino Mega fiel. Ein weiteres entscheidendes Kriterium f\u00fcr den Arduino Mega war die erh\u00f6hte Anzahl an Ein- und Ausgangspins, die zuk\u00fcnftige Erweiterungsm\u00f6glichkeiten f\u00fcr das Spielger\u00e4t\u00a0erm\u00f6glichen.</p>"},{"location":"DOC_DED_SOA_Software_Architecture/","title":"Software Architektur","text":""},{"location":"DOC_DED_SOA_Software_Architecture/#software-architecture","title":"Software Architecture","text":"classDiagram     class main {         cpp file with main code \\n(Controller)     }     main *--  Game_Logic     class Game_Logic{         Library with all          classes and methods          for the Game Logic (Model)     }     ASL *-- RGBmatrixPanel     class RGBmatrixPanel{         Hardware Abstraction Layer:*         Library provided by          the matrix manufacturer     }     class ASL{         Application service Layer*         Library with all classes         and methods for the          Hardware handling. (View)     }     main *-- ASL     ASL *-- HAL     RGBmatrixPanel *-- HAL     class HAL{         Hardware Abstraction Layer*     }"},{"location":"DOC_DED_SOA_Software_Architecture/#finite-state-machine-with-external-memory","title":"Finite State Machine (with external memory)","text":"stateDiagram-v2         [*] --&gt; s0     s0 : Display Setup Real Players         s0 --&gt; s1: Code Executed     s1 : Setup real Players         s1 --&gt; s2 : Green Button         s2 --&gt; s1: Code Executed     s2 : Modify real Player Number         s1 --&gt; s3c: Red Button     s3c : Display Setup Computer Players         s3c --&gt; s3: Code Executed     s3 : Setup Computer Players         s3 --&gt; s4 : Green Button     s4 : Modify Computer Player Number         s4 --&gt; s3: Code Excuted         s3 --&gt; s3d : Red Button     s3d: Display Setup Computer Player Mode         s3d --&gt; s3a: Code executed     s3a: Setup Computer Player Mode         s3a --&gt; s3b: Green Button         s3a --&gt; s4a: Red Button     s3b: Modify Computer Player Mode         s3b --&gt; s3a: Code Executed     s4a: Init Game Logic         s4a --&gt; s5: Init Complete     s5 : Wait for Dice Roll         s5 --&gt;s6 : Green Button     s6 : Roll the Dice          state if2 &lt;&lt;choice&gt;&gt;         s6 --&gt; if2 : Dice was rolled.         if2 --&gt; s5 : not a 6 and all players in starting square\\n and not completed 3 turns to roll the dice.         if2 --&gt; s9a: not a 6, all players in starting square\\n and completed 3 turns to roll the dice.         if2 --&gt; s8a: none of the other.         # Players ------------------     s7 : Wait for Player Input         s7 --&gt; s8a : Green Button (next token)     s8 : Display token         s8 --&gt; s7 : Code Executed         s7 --&gt; s9 : Red Button     s8a: Validate token         s8a --&gt; s8 : Valid Token found.         s8a --&gt; s9a: No Valid Token found.     s9 : move token         state if1 &lt;&lt;choice&gt;&gt;         s9 --&gt; if1 : Player finished move.         if1 --&gt; s5 : Player gets one more turn\\n (Dice value was 6.)         if1 --&gt; s9a : not all tokens in finishing square,\\n next player.         if1 --&gt; s10 : all tokens in finishing square.     s9a: Next Player         s9a --&gt; s5: Code Executed     s10: Game finished         s10 --&gt; s0 : Button pressed."},{"location":"DOC_DED_SOA_Software_Architecture/#game-logic-library","title":"Game Logic Library","text":""},{"location":"DOC_DED_SOA_Software_Architecture/#class-diagram","title":"Class Diagram","text":"<p><pre><code>note:   - : private\n        # : protected\n        + : public\n</code></pre>   classDiagram     %%{init:{'flowchart':{'nodeSpacing': 50, 'rankSpacing': 100}}}%%      class cla_session {         - uint8_t u8_player_quantity         - uint8_t u8_computer_quantity         + cla_player *array_players[4]         + uint8_t u8_is_occupied_player_id         + uint8_t u8_is_occupied_token_number          + cla_session(uint8_t _u8_player_quantity, uint8_t _u8_computer_quantity)         + Is_Occupied(uint8_t &amp;u8_is_occupied_player_id, uint8_t &amp;u8_is_occupied_token_number, uint8_t _u8_affected_track_position) bool         + Return_Home(uint8_t _u8_affected_track_position) bool         + Get_Player_Quantity()  uint8_t         + Get_Computer_Quantity() uint8_t      }      cla_session \"1\" *-- \"1..4\" cla_player     class cla_player {         # uint8_t u8_token_position[4]         # uint8_t u8_start_position         # uint8_t u8_player_id         # cla_session* obj_my_session          + cla_player(uint8_t _u8_start_position, uint8_t _u8_computer_quantity, cla_session* _obj_my_session)         + Calculate_Possible_Position(uint8_t _u8_token_number, uint8_t _u8_dice_value) uint8_t         + Move_Token(uint8_t _u8_token_number, uint8_t _u8_dice_value) uint8_t         + Get_Token_Position(uint8_t _u8_token_number) uint8_t         + Set_Token_Position(uint8_t _u8_token_number, uint8_t _u8_new_position) uint8_t         + Get_Token_Progress(uint8_t _u8_token_number) uint8_t         + Get_Player_Status() status         + Get_Player_Progress() uint8_t         + Is_Start_Field_Occupied_By_Own_Token() int8_t         + virtual Is_Computer() bool         + virtual Auto_Move(uint8_t _u8_dice_value, bool &amp;_bool_occupied_flag, uint8_t &amp;_u8_old_position) int8_t      }      cla_player &lt;|-- cla_manual_player     class cla_manual_player      cla_player &lt;|-- cla_computer_player     class cla_computer_player{         # mode u8_en_mode          + cla_computer_player(uint8_t _u8_player_id, uint8_t _u8_start_position, uint8_t _u8_computer_quantity, cla_session *_obj_my_session, mode _en_mode)         + Auto_Move(uint8_t _u8_dice_value, bool &amp;_bool_occupied_flag, uint8_t &amp;_u8_old_position) int8_t         + Is_Computer() bool     }      mode \"1\" --* \"1\" cla_computer_player     class mode{         &lt;&lt;typedef enum&gt;&gt;         Student         Professor     }</p>"},{"location":"DOC_DED_SOA_Software_Architecture/#token_position-and-token_progress","title":"token_position and token_progress","text":"<p><pre><code>token_position\n</code></pre> The absolute position of the token. The track squares are numbered the same for all players, so the starting track position for each player differs. <pre><code>token_progress\n</code></pre> The relative Position of the token. The track squares are numbered individually for each player, so the starting track position for each player has the same number.</p> <p>The following table shows all of the relative positions of the Players with the corresponding absolute position and Position name.</p> position Player 1 Player 2 Player 3 Player 4 absolute position starting square 1 1 1 1 1 1 starting square 2 2 2 2 2 2 starting square 3 3 3 3 3 3 starting square 4 4 4 4 4 4 track position 1 5 35 25 15 5 track position 2 6 36 26 16 6 track position 3 7 37 27 17 7 track position 4 8 38 28 18 8 track position 5 9 39 29 19 9 track position 6 10 40 30 20 10 track position 7 11 41 31 21 11 track position 8 12 42 32 22 12 track position 9 13 43 33 23 13 track position 10 14 44 34 24 14 track position 11 15 5 35 25 15 track position 12 16 6 36 26 16 track position 13 17 7 37 27 17 track position 14 18 8 38 28 18 track position 15 19 9 39 29 19 track position 16 20 10 40 30 20 track position 17 21 11 41 31 21 track position 18 22 12 42 32 22 track position 19 23 13 43 33 23 track position 20 24 14 44 34 24 track position 21 25 15 5 35 25 track position 22 26 16 6 36 26 track position 23 27 17 7 37 27 track position 24 28 18 8 38 28 track position 25 29 19 9 39 29 track position 26 30 20 10 40 30 track position 27 31 21 11 41 31 track position 28 32 22 12 42 32 track position 29 33 23 13 43 33 track position 30 34 24 14 44 34 track position 31 35 25 15 5 35 track position 32 36 26 16 6 36 track position 33 37 27 17 7 37 track position 34 38 28 18 8 38 track position 35 39 29 19 9 39 track position 36 40 30 20 10 40 track position 37 41 31 21 11 41 track position 38 42 32 22 12 42 track position 39 43 33 23 13 43 track position 40 44 34 24 14 44 finishing square 1 45 45 45 45 45 finishing square 2 46 46 46 46 46 finishing square 3 47 47 47 47 47 finishing square 4 48 48 48 48 48 <p>The following image shows the absolute Track positions:</p> <p></p>"},{"location":"DOC_DED_SOA_Software_Architecture/#player-status","title":"Player Status","text":"<pre><code>status Get_Player_Status() \n</code></pre> <p>Returns the Players status. Status is defined via typedef enum and can have the following values:</p> en_status Token(s) in Starting Square Token(s) on Game Track Token(s) in Finishing Square Start YES NO NO Start_Track YES YES NO Start_Finished YES NO YES Start_Track_Finished YES YES YES Error NO NO NO Track NO YES NO Finished NO NO YES Track_Finished NO YES YES"},{"location":"DOC_DED_SOA_Software_Architecture/#class-diagram-asl","title":"Class Diagram ASL","text":"classDiagram   class cla_display {         - uint8_t u8_matrix_a         - uint8_t u8_matrix_b         - uint8_t u8_matrix_c         - uint8_t u8_matrix_clk         - uint8_t u8_matrix_lat         - uint8_t u8_matrix_oe         - RGBmatrixPanel *obj_matrix         - uint8_t u8_track_positions[40][3]         - uint8_t u8_home_positions[4][4][2]         - uint8_t u8_finish_positions[4][4][2]         - uint8_t u8_smiley_postitions[26][2]         - int16_t u16_player_color[4][2]         - uint16_t u16_track_color         - en_blink_mode en_current_blink_mode         - int8_t i8_blink_counter         - en_blink_type en_current_blink_type         - uint8_t u8_blink_player_number         - int8_t i8_blink_second_player         - uint8_t u8_blink_old_position         - uint8_t u8_blink_new_position         - uint8_t u8_blink_state          + cla_display(uint8_t _u8_matrix_a, uint8_t u8_matrix_b, uint8_t u8_matrix_c, uint8_t \\n    u8_matrix_clk, uint8_t u8_lat, uint8_t u8_matrix_oe)         + void Set_Colors(uint8_t _u8_player_nr, uint16_t _u16_bright_color, uint16_t \\n _u16_dark_color)         + void Begin()         + void Display_Track()         + void Display_Players(uint8_t _u8_player_quantity,bool _bool_tokens_at_home = true)         + void Display_Restore()         + void Display_Current_Player(int8_t _i8_current_player_number, int8_t _i8_tokens_at_home = -1)         + void Display_Progress(int8_t _i8_current_player_number, uint8_t _u8_progress)         + void Display_Char(char _ch_first_letter = ' ', char _ch_second_letter = ' ', \\n char _ch_third_letter = ' ')         + void Display_Clear_Right()         + void Blink_Start(en_blink_mode _en_blink_mode, int8_t _i8_blink_cycles,\\n en_blink_type _en_blink_type, uint8_t _u8_blink_player_number, int8_t _i8_blink_second_player,\\n uint8_t _u8_new_position= 0, bool _bool_occupied_flag = true, uint8_t _u8_old_position = 0)         + bool Blink_Update(bool _bool_isr_active)         + void Blink_Stop()         + bool Blink_Is_On()         + void Modify_Position(uint8_t _u8_position, uint8_t _u8_player_number, bool bool_remove)         + void Move_Token(uint8_t _u8_player_nr, uint8_t _u8_remove_position, \\n uint8_t _u8_add_position)         + void Display_Dice(uint8_t _u8_dice_value, uint8_t _u8_dice_roll_counter,\\n int8_t _i8_current_player_number, bool _bool_animate = true)      }      class en_blink_mode{         &lt;&lt;enumeration&gt;&gt;         Slow         Fast         Off     }      class en_blink_type{         &lt;&lt;enumeration&gt;&gt;         token         token_thrown         starting_square         winner_animation     }      cla_display \"1\" --* \"1\" en_blink_type     cla_display \"1\" --* \"1\" en_blink_mode      class other_functions{         functions in ASL namespace         void Setup_Buttons()         void Setup_Dice()         uint8_t Roll_Dice()         void Delay_256(uint16_t _u16_delay)     }      class en_state{         &lt;&lt;enumeration&gt;&gt;         display_setup_real_players         setup_real_players         modify_real_player_number         display_setup_computer_players         setup_computer_players         modify_computer_player_number         display_setup_computer_player_mode         setup_computer_player_mode         modify_computer_player_mode                 init_game_logic                             wait_for_dice_roll                          roll_the_dice                               wait_for_player_input                       display_token                               validate_token                              move_token                                  next_player                                 game_finished                           }"},{"location":"DOC_DED_SOA_Software_Architecture/#timers","title":"Timers","text":"<p>The Game uses 5 of the 6 timers, which is one of the reasons an ATMega2560 was chosen over the ATMega328p:</p> <ul> <li>Timer 0: ( 8Bit) Runs from 0 to 5 to create a \"random\" Dice value</li> <li>Timer 1: (16Bit) Used for the LED matrix</li> <li>Timer 2: ( 8Bit) Reserved for future features, currently used for measuring interupt durations</li> <li>Timer 3: (16Bit) Used for Button Debounce</li> <li>Timer 4: (16Bit) Used for Led Blinking</li> <li>TImer 5: (16Bit) Used for Delay function.</li> </ul> <p>Timer 0 is used to create a \"random\" dice value. The value is random, because no prescaler is used, so pressing the button at the right time to get a desired value is basically impossible. Therefore, the timer is set up in CTC mode without any interupts.</p> <p>Timer 1 is used for refreshing the LED matrix. No prescaler is used for this timer and its value is read out at certain points in the function responsible for refreshing the matrix and the interval time for the refresh cycle is calculated together with other parameters.</p> <p>Timer 2 is currently used for measuring the interupt time when using the TIMING_DEBUG_INTERN mode. Timer 2 is then set to no prescaler. It is set to 0 on Interupt start. The Timer value is read and written to an array on Interupt end.</p> <p>Timer 3 is used for debouncing the Buttons. It will be started in the interupt routine for the Buttons. Prescaler is set to 1/1024. The debounce time can be varied using the <code>DEBOUNCE_TIME</code> define. </p> <p>Timer4 is used for Led Blinking. It will trigger an interupt at a given time interval. Time interval is given by the <code>FAST_BLINK</code> and <code>SLOW_BLINK</code> defines. The values for the defines were calculated using the DOC_ENG_CALC_Timer4_Blinking.xlsx Excel sheet.</p>  Excel Tabelle: DOC_ENG_CALC_Timer4_Blinking.xlsx  <p></p> <p>Timer5 is used for the <code>Delay_256()</code> functions. The Delay function differs from the blink function, because it will delay the program until the given time has passed. This is useful in some cases, because the program is NOT supposed to perform any Task until the Animation is finished.</p>"},{"location":"DOC_DED_SYA_System_Architecture/","title":"Systemarchitektur:","text":"<p>Der grundlegende Gedanke unser Projekt aufzubauen war der, dass wir die Spielelogik und das Anzeigen auf der LED-Matrix jeweils in einer Bibliothek implementieren. Dadurch kam f\u00fcr uns das MVC-Modell f\u00fcr unsere Systemarchitektur infrage. </p>"},{"location":"DOC_DED_SYA_System_Architecture/#modell-view-controller-mvc","title":"Modell View Controller (MVC)","text":"<ul> <li> <p>1 - Modell (Model): Die Bibliothek f\u00fcr die Spielelogik stellt das \"Modell\" dar. Sie enth\u00e4lt die grundlegenden Regeln und Abl\u00e4ufe des Spiels, wie die Spiellogik, Spielzust\u00e4nde, Spielerpositionen usw.</p> </li> <li> <p>2 - Ansicht (View): Die Bibliothek f\u00fcr die Anzeige auf der LED-Matrix stellt die \"Ansicht\" dar. Sie ist verantwortlich f\u00fcr die Darstellung des aktuelle Phase des Spiels auf der Benutzeroberfl\u00e4che (in diesem Fall auf der LED-Matrix). Sie k\u00fcmmert sich um die visuelle Darstellung des Spielbretts, Spielerfiguren und anderer Spielinformationen.</p> </li> <li> <p>3 - Controller: Die main.cpp ist der \"Controller\". Er handelt die Benutzereingaben ab, koordiniert die Interaktion zwischen Modell und Ansicht und aktualisiert den Spielzustand entsprechend. Der Controller entscheidet, welche Aktionen basierend auf Benutzereingaben oder dem aktuellen Zustand des Spiels ausgef\u00fchrt werden sollen, und ruft entsprechende Funktionen im Modell auf, um den Zustand des Spiels zu \u00e4ndern. Er kann auch die Ansicht aktualisieren, um \u00c4nderungen im Spielzustand widerzuspiegeln.</p> </li> </ul> <p>In diesem Sinne ist unsere Systemarchitektur an das MVC-Muster angelehnt, wobei die Spielelogik das Modell darstellt, die Bibliothek f\u00fcr die Anzeige die Ansicht und die main.cpp den Controller. Dadurch bietet das MVC-Muster eine n\u00fctzliche Struktur, um die Verantwortlichkeiten der Komponenten zu organisieren.</p> graph LR;         M((Model))         V((View))         C((Controller))     M --&gt; C;     C --&gt; M;     C --&gt; V;     V --&gt; C;"},{"location":"DOC_ENG_DA_Additional_Drawings_and_Datasheets/","title":"Additional Information","text":""},{"location":"DOC_ENG_DA_Additional_Drawings_and_Datasheets/#anschlussplan","title":"Anschlussplan","text":"<p>Im folgenden ist der Anschlussplan f\u00fcr die Verwendung des ATMega2560 dargestellt.</p> <p></p>"},{"location":"DOC_ENG_DA_Additional_Drawings_and_Datasheets/#gehause","title":"Geh\u00e4use","text":"<p>Das Geh\u00e4use wurde f\u00fcr den 3d-Druck entworfen. Die CAD-Datei CAD_ENG_OUT_Geh\u00e4use.stl kann hier angesehen werden.</p>"},{"location":"DOC_ENG_DA_Additional_Drawings_and_Datasheets/#datenblatter","title":"Datenbl\u00e4tter","text":"<p>S\u00e4mtliche Datenbl\u00e4tter der Verwendeten Komponenten sind im Ordner <code>Engineering/Datasheets</code> zu finden (Hier klicken).</p>"},{"location":"DOC_ENG_TA_Trades_Analysis/","title":"Interupt Analyse","text":"<p>Um einen reibungsfreien Programmablauf sicherzustellen, wurde die Dauer aller Interupts gemessen. Dar\u00fcber hinaus wurde bei durch Timernutzung automatisch wiederholten Interupts die Frequenz aufgezeichnet. Dabei wurden die Taktzyklen gemessen. Anschlie\u00dfend wurde ein Mittelwert ermittelt und daraus die Zeit in Mikrosekunden berechnet. Ebenfalls wurde der Extremfall des Maximalwertes betrachtet, da dieser Wert f\u00fcr den Ablauf des Programms kritisch werden kann.</p>  Excel Tabelle: DOC_ENG_TA_Interupt_Messungen.xlsx  <p>Dabei l\u00e4sst sich festhalten, dass keiner der Werte krtisch gro\u00df wird. Der l\u00e4ngste Interupt liegt bei 10,31 us, was bei einer Interupt-frequenz von 8 Hz (Taktdauer 0,125 s) 0,0082 % der Taktdauer entspricht.</p> <p>In der folgenden Grafik ist die ben\u00f6tigte Zeitdauer der verschiedenen Interupts dargestellt. Dabei wurde ausschlie\u00dflich beim ISR des Timer 1 (Matrix refresh) die Wiederholung des Interupts eingezeichnet, da bei allen anderen Interupts die Wiederholung eine Skalierung der Zeitachse ben\u00f6tigen w\u00fcrde, bei der die eigentliche Dauer der Interupts nicht mehr erkennbar w\u00e4re.</p> <pre>5fbb1f93-bebc-473a-af59-dbe99e837292</pre> <p>Selbstverst\u00e4ndlich werden die Interuptroutinen auf dem ATMega2560 nicht gleichzeitig ausgef\u00fchrt. Dabei unterbricht ein w\u00e4hrend einer anderen Interuptserviceroutine eintreffender Interupt die laufende Interuptserviceroutine nicht, sondern wird direkt im Anschluss ausgef\u00fchrt. Entsprechend tritt auch kein Problem bei der Kombination des Matrix-Refresh Interupts mit dem Interupt des Timers 4, welcher f\u00fcr das Blinken des Hauses zust\u00e4ndig ist, auf. Der Matrix Interupt wird einfach im Anschluss ausgef\u00fchrt, wobei der Jitter des Interupts  f\u00fcr den Benutzer nicht erkennbar ist. Dieser Fall ist in der n\u00e4chsten Abbildung genauer betrachtet.</p> <pre>d58b97ee-24af-4944-8a4c-1bd88e08600b</pre>"},{"location":"DOC_MAD_COM_Configuration_Management/","title":"Configuration Management","text":""},{"location":"DOC_MAD_COM_Configuration_Management/#github-repository","title":"Github Repository","text":""},{"location":"DOC_MAD_COM_Configuration_Management/#ordner-struktur","title":"Ordner-Struktur","text":"<p>Im Github Repository ist die nachfolgende Ordnerstruktur zu finden.</p> <ul> <li>Requirements </li> <li>Design_Description</li> <li>Management_Development</li> <li>Test_Specification_Report</li> <li>Engineering</li> </ul> <p>Es ist darauf zu achten, die Dateien im richtigen Ordner abzulegen. Die Ordner <code>docs</code>, <code>.devcontainer</code> und <code>.github</code> dienen ausschlie\u00dflich dem Ablegen von Konfigurationsdateien!</p>"},{"location":"DOC_MAD_COM_Configuration_Management/#regeln-zur-dateibenennung","title":"Regeln zur Dateibenennung","text":"<p>Dateien m\u00fcssen nach den folgenden Schema benannt werden:</p> <pre><code>&lt;Dateityp&gt;_&lt;Ordnerk\u00fcrzel&gt;_&lt;Kurzname&gt;_&lt;dateiname (individuell)&gt;.&lt;Dateiendung&gt;\n</code></pre> <p>Dateityp:</p> <ul> <li><code>DOC</code> f\u00fcr Dokumentation</li> <li><code>COD</code> f\u00fcr Code. Bei Code reicht die Anwendung dieses Schemas auf den \u00fcbergeordneten Ordner.</li> <li><code>PIC</code> f\u00fcr Bilder (nur falls zwingend notwendig f\u00fcr die Dokumentation!)</li> <li><code>CAD</code> f\u00fcr CAD-Dateien.</li> </ul> <p>Ordnerk\u00fcrzel:</p> <ul> <li>Requirements: <code>REQ</code></li> <li>Design_Description: <code>DED</code></li> <li>Management_Development: <code>MAD</code></li> <li>Test_Specification_Report: <code>TES</code></li> <li>Engineering: <code>ENG</code></li> </ul> <p>Kurzname: Kurzname, individuell. 2-3 Buchstaben.</p> <p>Dateiname: ausgeschriebener Dateiname. Leerzeichen mit Unterstrich.</p>  Eine korrekte Benennung der Dateien ist unerl\u00e4sslich f\u00fcr das automatische Bauen der Projektwebsite."},{"location":"DOC_MAD_COM_Configuration_Management/#github-codespace","title":"Github Codespace","text":"<p>F\u00fcr die Programmierung der Spiellogik wurde ein Github Codespace eingerichtet. In diesem sind ben\u00f6tigte Abh\u00e4ngigkeiten f\u00fcr die Entwicklung der Spiellogik Bibliothek bereits vorinstalliert. F\u00fcr die Programmierung des Ger\u00e4tecodes eignet sich dieser Codespace jedoch weniger, da eine Anbindung von Hardwarekomponenten (Programmer) an den Codespace konfigurationsbedingt nicht m\u00f6glich ist. F\u00fcr diesen Fall empfielt sich die lokale Nutzung von PlatformIO auf einem Rechner mit Linux-basierten Betriebssystem.</p> <p>Der Github Codespace verwendet die in der Datei <code>.devcontainer/Dockerfile</code> enthaltene Docker-Konfiguration. Diese kann alternativ zur Nutzung mit dem Github-Codespace auch als lokaler Docker-Container genutzt werden.</p>"},{"location":"DOC_MAD_COM_Configuration_Management/#cmake-organisation","title":"CMake Organisation","text":"<p>Um die Spielelogik zu entwickeln und testen wird CMake verwendet. Die Header und Source Files der Logik befinden sich in einem Unterordner im lib-Verzeichnes (<code>Game_Logic</code>). Im gleichem Pfad befindet sich die erste von 2 CMakeLists.txt, diese gibt vor wie das Projekt gebaut werden muss und wo der Code der Logik und der Tests zu finden sind. Die Logik wird mittels Catch2 Tests im Test-Verzeichnis auf Funktionsf\u00e4higkeit gepr\u00fcft. In diesem Pfad befindet sich die zweite CMakeLists.txt, diese dient zur Konfiguration der Catch2-Tests.  Das ganze Projekt kann durch den Befehl <code>./runcmake.sh</code> in der Kommandozeile gebaut werden. Dabei werden auch im Anschluss die erstellten Testdateien ausgef\u00fchrt.</p>"},{"location":"DOC_MAD_COM_Configuration_Management/#nutzung-von-platformio-fur-die-mikrocomputerprogrammierung","title":"Nutzung von PlatformIO f\u00fcr die Mikrocomputerprogrammierung","text":"<p>F\u00fcr die Programmierung des Arduinos wurde die <code>PlatformIO</code> Extension f\u00fcr <code>VSCode</code> verwendet. Dies bietet insbesondere beim Einbinden und Verwalten von Bibliotheken enorme Vorteile gegen\u00fcber der <code>ArduinoIDE</code>. PlatformIO bietet dabei eine Grafische Oberfl\u00e4che zum Kompilieren und Flashen des Codes sowie einen Seriellen Monitor zum Auslesen der Seriellen Schnittstelle.</p>"},{"location":"DOC_MAD_COM_Configuration_Management/#automatisches-bauen-der-projektwebsite","title":"Automatisches Bauen der Projektwebsite","text":"<p>Die Gesamte Projektdokumentation ist \u00fcber eine Projektwebsite einsehbar. Diese Website wird bei jedem Push auf dem Main Branch automatisch neu gebaut. F\u00fcr das Bauen der Website kommt das Programm <code>mkdocs</code> zum Einsatz. Dieses wurde so konfiguriert, dass eine Einbindung von in <code>Mermaid</code> oder <code>PlantUML</code> gezeichneten Grafiken m\u00f6glich ist. <code>mkdocs</code> bezieht den Inhalt der Website aus den in den jeweiligen Ordnern gespeicherten Markdown-Dateien, die die Dokumentation enthalten. Diese werden beim Automatischen Bauen der Website zusammengesucht und f\u00fcr die Ver\u00f6ffentlichung in HTML umgewandelt. Dar\u00fcber hinaus wird mit Doxygen eine Code-Dokumentation erzeugt, die dann ebenfalls \u00fcber die Website einsehbar ist.</p>"},{"location":"DOC_MAD_COM_Configuration_Management/#lokales-hosten-der-projektwebsite","title":"Lokales Hosten der Projektwebsite","text":"<p>Zu Testzwecken kann es durchaus sinnvoll sein, die Projektwebsite tempor\u00e4r lokal zu Hosten, z.B. um die korrekte Einbindung von Grafiken zu testen. Im folgenden wird Schritt f\u00fcr Schritt erkl\u00e4rt, wie die Website lokal gehostet werden kann.</p> <p>Die folgende Anleitung erkl\u00e4rt das Vorgehen bei der Verwendung von Linux oder MacOS. F\u00fcr Windows-Nutzer empfielt sich die Nutzung des Windows Subsystem for Linux (WSL) oder des in der Datei <code>.devcontainer/Dockerfile</code> konfigurierten Docker-Containers.</p> <p>In den folgenden Schritten wird davon ausgegangen, das ein Terminal-Fenster in der obersten Ebene der Ordnerstruktur des Projektes ge\u00f6ffnet wurde. Eventuell m\u00fcssen Shell-Skripte mittels  <pre><code>chmod +x &lt;Pfad/Dateiname.sh&gt;\n</code></pre> ausf\u00fchrbar gemacht werden. Der Teil <code>&lt;Pfad/Dateiname.sh&gt;</code> ist dabei durch den Pfad und Dateinamen des betroffenen Shell-Skriptes zu ersetzen.</p>"},{"location":"DOC_MAD_COM_Configuration_Management/#schritt-1-installation-von-doxygen","title":"Schritt 1: Installation von Doxygen","text":"<p>Mkdocs ben\u00f6tigt doxygen f\u00fcr das Bauen der Website. Mit </p> <pre><code>doxygen --version\n</code></pre> <p>kann gepr\u00fcft werden, ob doxygen bereits installiert ist. Sollte dies nicht der Fall sein, kann doxygen mit den Befehlen</p> <pre><code>sudo apt-get update\nsudo apt-get install -y doxygen # Linux\n</code></pre> <p>installiert werden. Bei der Nutzung von MacOS empfielt sich die Nutzung von Homebrew, falls dieses bereits installiert ist:</p> <pre><code>brew install doxygen # MacOS\n</code></pre>"},{"location":"DOC_MAD_COM_Configuration_Management/#schritt-2-erstellen-eines-python-environments","title":"Schritt 2: Erstellen eines Python Environments","text":"<p>F\u00fcr das Erstellen eines Python Environments wurde ein Shell-Skript geschrieben, mit dem das Environment automatisch erstellt und konfiguriert wird. Dazu ist der folgende Befehl im Terminal einzugeben:</p> <pre><code>./docs/env_setup.sh\n</code></pre>"},{"location":"DOC_MAD_COM_Configuration_Management/#schritt-3-erstellen-und-hosten-der-seite","title":"Schritt 3: Erstellen und Hosten der Seite","text":"<p>Mit dem Skript</p> <pre><code>./docs/launch_site.sh\n</code></pre> <p>wird das soeben erstellte Python-environment automatisch gestartet und der Befehl <code>mkdocs serve</code> ausgef\u00fchrt, welcher die Website unter <code>http://127.0.0.1:8000/</code> verf\u00fcgbar macht.</p> <p>Mit der Tastenkombination <code>Strg</code>+ <code>C</code> (<code>control</code> + <code>C</code> unter MacOS) kann Mkdocs wieder beendet werden. Zum erneuten Starten kann direkt bei Schritt 3 eingestiegen werden.</p> <p>Dar\u00fcber hinaus kann die Website mit </p> <pre><code>./docs/copy_docs.sh\n</code></pre> <p>aktualisiert werden.</p> <pre><code>./docs/remove_docs.sh\n</code></pre> <p>r\u00e4umt den <code>docs/docs</code>-Ordner auf. Die Verwendung des Skriptes empfielt sich nach dem Abschluss der Arbeiten mit MkDocs.</p> Tipp: Alternativ zum Hosten der Seite kann auch der Quellcode erzeugt werden. Dazu muss zuerst das Python-Environment mittels <code>source docs/env/bin/activate</code> aktiviert werden. Anschlie\u00dfend kann durch Ausf\u00fchren des Befehls <code>mkdocs build</code> im <code>docs/</code>-Ordner die Seite gebaut werden. Der Quellcode ist dann im Ordner <code>docs/site</code> zu finden. Diese M\u00f6glichkeit eignet sich zu Untersuchen der Dateistruktur und des Websiteaufbaus, ist aber zum Betrachten der Seite eher ungeeignet, da CSS-Stylesheets eventuell nicht korrekt verlinkt werden.   Automatisch generierte Ordner d\u00fcrfen nicht auf das Repository gepusht werden!"},{"location":"DOC_MAD_COM_Configuration_Management/#onedrive","title":"Onedrive","text":"<p>Da Github f\u00fcr die Verwaltung ausgew\u00e4hlter Dateitypen wie beispielsweise <code>.xlsx</code>-Dateien eher ungeeignet ist, steht f\u00fcr diese Dateien als Ausweich-Option ein Onedrive-Ordner zur Verf\u00fcgung. In diesem Ordner ist dieselbe Ordnerstruktur vorhanden, wie sie im Kapitel Ordner-Struktur bereits f\u00fcr das Github-Repository erl\u00e4utert wurde. </p>  Beim Ablegen einer Datei auf OneDrive ist darauf zu achten, im zugeh\u00f6rigen Teil der Dokumentation auf dem Git-Repository auf die Datei zu verweisen/-linken."},{"location":"DOC_MAD_CRO_Cost_Risk_Opportunities/","title":"Cost, Risk and Opportunity","text":""},{"location":"DOC_MAD_CRO_Cost_Risk_Opportunities/#cost","title":"Cost","text":"Excel Tabelle: DOC_MAD_CRO_Bauteileliste.xlsx"},{"location":"DOC_MAD_CRO_Cost_Risk_Opportunities/#risks-and-opportunities","title":"Risks and Opportunities","text":"Excel Tabelle: DOC_MAD_CRO_Risks_and_Opportunities.xlsx"},{"location":"DOC_MAD_SH_Schedule/","title":"Schedule","text":""},{"location":"DOC_MAD_SH_Schedule/#schedule","title":"Schedule","text":"<p>gantt     tickInterval 4week     weekday monday     dateFormat YYYY-MM-DD     section Software         Software Architecture design        :a1, 2024-01-13, 3d         Software Prototype Implementation   :a2, after a1, 20d         Software Prototype Testing          :a3, 2024-01-20, 20d         Software Implemantation and Testing of special Features :2024-02-10, 2024-08-01     section Hardware         Prototype Hardware Purchasing       :b1, 2024-01-10, 5d         Prototype build                     :after b1, 24d         Prototype testing                   :2024-01-20, 24d         Hardware finalisation and testing   :2024-02-22, 2024-04-01     section Management         writing Prototype Documentation     :c1, 2024-01-18, 2024-02-22         Define Requirements                 :c2, 2024-01-08, 2024-01-13     section Phases*         Pitch                               :milestone, 2023-12-07         Engineering Phase                   :d1, 2023-12-07, 2024-01-13         Design Phase                        :d2, after d1, 3d         Requirements Verification           : milestone, 2024-01-26         Implementation Phase                :d3, after d2, 2024-02-12         Validation Phase                    :d4, after d3, 2024-02-22         working Prototype                   :milestone, 2024-02-22          Prototype Presentation              :milestone, 2024-03-14         Product Release                     :milestone, 2024-08-14 *Phases according to PMBOK (Project Management Body of Knowledge) </p>"},{"location":"DOC_MAD_SR_coding_rules/","title":"Coding rules","text":""},{"location":"DOC_MAD_SR_coding_rules/#general-rules","title":"General Rules","text":"<ol> <li>Code and comments must be written in English.</li> <li>Code must be written in C/C++.</li> <li>Every function/method except <code>main()</code> must have a doxygen comment above.</li> <li>Comments must be written above the code descripted.</li> <li>Pre-defined values must be defined using <code>#define</code>.</li> <li>DEFINE macros must be written in capital letters.</li> <li>All variables in classes must be protected or private, if possible.</li> </ol>"},{"location":"DOC_MAD_SR_coding_rules/#naming-rules","title":"Naming Rules","text":""},{"location":"DOC_MAD_SR_coding_rules/#general","title":"General","text":"<ul> <li>Spaces are written as underscores <code>_</code>.</li> </ul>"},{"location":"DOC_MAD_SR_coding_rules/#functions","title":"Functions","text":"<ul> <li>First letter must be written in Capital</li> </ul>"},{"location":"DOC_MAD_SR_coding_rules/#variables","title":"Variables","text":"<ul> <li>Capital letters must not be used.</li> <li><code>int</code> variables must start with <code>i_</code>.</li> <li><code>long</code> variables must start with <code>l_</code>.</li> <li><code>long long</code> variables must start with <code>ll_</code>.</li> <li><code>uint8_t</code> variables must start with <code>u8_</code>.</li> <li><code>uint16_t</code> variables must start with <code>u16_</code>.</li> <li><code>uint32_t</code> variables must start with <code>u32_</code>.</li> <li><code>uint64_t</code> variables must start with <code>u64_</code>.</li> <li><code>bool</code> variables must start with <code>bool_</code>.</li> <li><code>float</code> variables must start with <code>fl_</code>.</li> <li><code>char</code> variables must start with <code>ch_</code>.</li> <li><code>strings</code> must start with <code>str_</code>.</li> <li><code>vectors</code> must start with <code>vec_</code>.</li> <li><code>enum</code> variables must start with <code>en_</code>.</li> <li>transfer parameters begin with an underscore <code>_</code> in addition to the above.</li> <li>Variables of a <code>typedef</code> start with the starting letters of the originating type listed above.</li> </ul>"},{"location":"DOC_MAD_SR_coding_rules/#classes","title":"Classes","text":"<ul> <li><code>classes</code> must start with <code>cla_</code>.</li> <li><code>objects</code> created from a class must start with <code>obj_</code></li> </ul>"},{"location":"DOC_REQ_RE_Requirements/","title":"Requirements","text":"Excel Tabelle: DOC_REQ_RE_Requirements.xlsx"},{"location":"DOC_TES_CAS_Test_Cases/","title":"Test Specification and Report","text":""},{"location":"DOC_TES_CAS_Test_Cases/#test-cases","title":"Test Cases","text":""},{"location":"DOC_TES_CAS_Test_Cases/#unittests-mit-dem-catch2-framework","title":"Unittests mit dem Catch2 Framework","text":"<p>Die in der Spiellogik implementierten Funktionen werden durch einzelne Unittests auf fehlerfreie Funktionalit\u00e4t getestet. Diese Art von Test erm\u00f6glicht es, nicht funktionsf\u00e4hige Codeabschnitte bereits w\u00e4hrend der Programmierung zu erkennen und fr\u00fchzeitig einzugreifen. Ein wesentlicher Vorteil besteht darin, dass keine dedizierte Hardware f\u00fcr die Tests erforderlich ist. Dadurch kann jeder Programmierer unabh\u00e4ngig von der Verf\u00fcgbarkeit spezifischer Hardware mit diesen Tests arbeiten.</p>"},{"location":"DOC_TES_CAS_Test_Cases/#test-uber-die-debugging-schnittstelle","title":"Test \u00fcber die Debugging Schnittstelle","text":"<p>Um das Nachstellen von Szenarien auf dem Spielfeld zu vereinfachen und Zeit zu sparen, wurde eine externe Debugging-Schnittstelle f\u00fcr Tests entwickelt. Diese Schnittstelle erm\u00f6glicht es, W\u00fcrfelwerte festzulegen, indem 3 Bits \u00fcber Leitungen nach au\u00dfen gef\u00fchrt werden. Durch die korrekte Schalterstellung k\u00f6nnen W\u00fcrfelwerte zwischen 0 und 15 eingestellt werden. Hierf\u00fcr muss der DICE_MODE in der defines.hpp auf den Wert 1 gesetzt werden. Zus\u00e4tzlich bietet ein anderer Modus die M\u00f6glichkeit, verschiedene Zahlenwerte zwischen 0 und 255 in einem Array zu speichern. Anhand dieser Werte k\u00f6nnen Spiele und verschiedene Szenarien nachgestellt und getestet werden. Hierf\u00fcr muss der DICE_MODE auf den Wert 2 gestellt werden. Die Debugging-Schnittstelle zeigt zus\u00e4tzlich den aktuellen Status des Zustandsgraphen auf den ersten 4 Bits an. Danach folgen zwei Bits f\u00fcr die Anzahl der Spieler und zwei Bits f\u00fcr die Anzahl der Computerspieler, die mithilfe von LEDs dargestellt werden. Im Spielmodus werden die ausgew\u00e4hlte Spielernummer und die ausgew\u00e4hlte Tokennummer auf den letzten 4 Bits angezeigt.</p>"},{"location":"DOC_TES_CAS_Test_Cases/#prufgerat","title":"Pr\u00fcfger\u00e4t","text":"<p>Um die Blinkfrequenz des schnellen und langsamen Blinkens zu messen, wurde ein zus\u00e4tzlicher Arduino als Messeinrichtung verwendet. Auf diesem Arduino wurde ein Code geschrieben, der die Zeiten zwischen den Flankenwechseln an seinem Eingang misst und daraus die Frequenz berechnet. Die Zeiten sowie die entsprechenden Frequenzen, in denen der Eingang High bzw. Low war, werden im Serial Monitor ausgegeben. Bei der Erstellung des Programmcodes lag der Fokus mehr auf der Lesbarkeit als auf der Effizienz, da dieser Code ausschlie\u00dflich f\u00fcr das Pr\u00fcfger\u00e4t und nicht in einem Serienprodukt verwendet wird.</p>"},{"location":"DOC_TES_CAS_Test_Cases/#testdokumentation","title":"Testdokumentation","text":"<p>Die untenstehende Excel-Tabelle wurde verwendet, um die Testf\u00e4lle zu strukturieren und zu dokumentieren. Die zu testenden Requirements wurden in verschiedene Testf\u00e4lle aufgeteilt, die als Registerkarten im Excel-Fenster angezeigt werden. Dar\u00fcber hinaus wurde ein Verification Control Document erstellt, in dem aufgef\u00fchrt ist, welches Requirement in welchem Testfall getestet wurde.</p>  Excel Tabelle: DOC_TES_CAS_Test_Cases.xlsx"},{"location":"DeviceCode/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace ASL <ul> <li>class cla_display display handler </li> </ul> </li> <li>namespace LOGIC <ul> <li>class cla_computer_player This class represents a computer opponent in the game. It provides methods for automatic movement of tokens. It is derived from the cla_player . </li> <li>class cla_manual_player This class represents a manual player in a game. It is derived from the cla_player class. </li> <li>class cla_player This class represents a player in the game. It provides methods for moving tokens and checking the status of the player. It is an abstract class and has two derived classes: cla_computer_player andcla_manual_player . </li> <li>class cla_session The cla_session class is the main class of the game logic. It initializes the players with their methods and it provides essential methods for the game logic. </li> </ul> </li> </ul>"},{"location":"DeviceCode/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir Engineering <ul> <li>dir COD_ENG_OUT_arduino_code <ul> <li>dir include <ul> <li>file defines.hpp This file contains all the defines for the project. </li> </ul> </li> <li>dir lib <ul> <li>dir ASL <ul> <li>file ASL.cpp This file contains the implementation of the Applications Service Layer. </li> <li>file ASL.hpp This is the header file for the ASL library. </li> </ul> </li> <li>dir Game_Logic <ul> <li>file logic.cpp This file contains the implementation of the game logic. </li> <li>file logic.hpp This file is the header file for the game logic library. </li> </ul> </li> </ul> </li> <li>dir src <ul> <li>file animations.cpp This file contains the animations for the game. </li> <li>file interupt.cpp This file contains all interupt routines. </li> <li>file main.cpp This file contains the main loop and setup of the game. </li> </ul> </li> <li>dir test <ul> <li>file 001-TestCase_Requirements.cpp This file contains the test cases for the requirements of the game logic. </li> <li>file 002-TestCase_ComputerPlayer.cpp Test cases for the computer player. </li> <li>file 003-TestCase_Session_and_Player.cpp Test cases for various situations during a game. </li> <li>file marked_dice.hpp This file contains the dice values for the test cases. </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"DeviceCode/namespaceASL/","title":"Namespace ASL","text":"<p>Namespace List &gt; ASL</p>"},{"location":"DeviceCode/namespaceASL/#classes","title":"Classes","text":"Type Name class cla_display display handler"},{"location":"DeviceCode/namespaceASL/#public-types","title":"Public Types","text":"Type Name enum en_blink_mode enum en_blink_type enum en_state the states of the finite state machine."},{"location":"DeviceCode/namespaceASL/#public-functions","title":"Public Functions","text":"Type Name void Delay_256 (uint16_t _u16_delay) Delay. uint8_t Roll_Dice () roll the Dice. void Setup_Buttons () setup function for the Buttons void Setup_Dice () setup function for the Dice"},{"location":"DeviceCode/namespaceASL/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"DeviceCode/namespaceASL/#enum-en_blink_mode","title":"enum en_blink_mode","text":"<pre><code>enum ASL::en_blink_mode {\n    off = 0,\n    fast,\n    slow\n};\n</code></pre>"},{"location":"DeviceCode/namespaceASL/#enum-en_blink_type","title":"enum en_blink_type","text":"<pre><code>enum ASL::en_blink_type {\n    token = 0,\n    token_thrown,\n    starting_square,\n    winner_animation\n};\n</code></pre>"},{"location":"DeviceCode/namespaceASL/#enum-en_state","title":"enum en_state","text":"<p>the states of the finite state machine. <pre><code>enum ASL::en_state {\n    display_setup_real_players = 0,\n    setup_real_players,\n    modify_real_player_number,\n    display_setup_computer_players,\n    setup_computer_players,\n    modify_computer_player_number,\n    display_setup_computer_player_mode,\n    setup_computer_player_mode,\n    modify_computer_player_mode,\n    init_game_logic,\n    wait_for_dice_roll,\n    roll_the_dice,\n    wait_for_player_input,\n    display_token,\n    validate_token,\n    move_token,\n    next_player,\n    game_finished\n};\n</code></pre></p> <p>Defines the states of the finite state machine. Starting state is 1. </p>"},{"location":"DeviceCode/namespaceASL/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"DeviceCode/namespaceASL/#function-delay_256","title":"function Delay_256","text":"<p>Delay. <pre><code>void ASL::Delay_256 (\n    uint16_t _u16_delay\n) \n</code></pre></p> <p>This function is a simple delay function. It uses Timer 5 with /256 clk divider to count to the value in the transfer parameter. when reached, the function returns.</p> <p>Parameters:</p> <ul> <li><code>_u16_delay</code> The number of timer cycles to delay. </li> </ul>"},{"location":"DeviceCode/namespaceASL/#function-roll_dice","title":"function Roll_Dice","text":"<p>roll the Dice. <pre><code>uint8_t ASL::Roll_Dice () \n</code></pre></p> <p>This function reads the TCNT register value, adds one and returns it. In Order to receive a Value between 1 and 6, the Setup_Dice() function must be called beforehand (ONCE). </p>"},{"location":"DeviceCode/namespaceASL/#function-setup_buttons","title":"function Setup_Buttons","text":"<p>setup function for the Buttons <pre><code>void ASL::Setup_Buttons () \n</code></pre></p> <p>Sets Buttons on Pin 2 and 3 to input and enables interupt for them. This function must be called ONCE at the beginning of the program in Order for the Buttons to work. </p>"},{"location":"DeviceCode/namespaceASL/#function-setup_dice","title":"function Setup_Dice","text":"<p>setup function for the Dice <pre><code>void ASL::Setup_Dice () \n</code></pre></p> <p>Sets Timer 0 to count to 5 using CTC mode, so the value read from the TCNT register can be used as a dice value after adding 1. This function must be called ONCE at the beginning of the program in Order for the Dice to work. </p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/lib/ASL/ASL.hpp</code></p>"},{"location":"DeviceCode/classASL_1_1cla__display/","title":"Class ASL::cla_display","text":"<p>ClassList &gt; ASL &gt; cla_display</p> <p>display handler More...</p> <ul> <li><code>#include &lt;ASL.hpp&gt;</code></li> </ul>"},{"location":"DeviceCode/classASL_1_1cla__display/#public-functions","title":"Public Functions","text":"Type Name void Begin () Initial Setup. bool Blink_Is_On () Is Blinking On? void Blink_Start (en_blink_mode _en_blink_mode, int8_t _i8_blink_cycles, en_blink_type _en_blink_type, uint8_t _u8_blink_player_number, int8_t _i8_blink_second_player, uint8_t _u8_new_position=0, bool _bool_occupied_flag=true, uint8_t _u8_old_position=0) Blink method. void Blink_Stop () Stop blinking. bool Blink_Update (bool _bool_isr_active) Update the Blink state. void Display_Char (char _ch_first_letter=' ', char _ch_second_letter=' ', char _ch_third_letter=' ') Display the Word. void Display_Clear_Right () clears the right half of the display. void Display_Current_Player (int8_t _i8_current_player_number, int8_t _i8_tokens_at_home=-1) Display the Current Player. void Display_Dice (uint8_t _u8_dice_value, uint8_t _u8_dice_roll_counter, int8_t _i8_current_player_number, bool _bool_animate=true) Display the dice. void Display_Players (uint8_t _u8_player_quantity, bool _bool_tokens_at_home=true) Display the Players all in home. void Display_Progress (int8_t _i8_current_player_number, uint8_t _u8_progress) Display the Progress This method can display the progress of the Player. void Display_Restore () Restore Display to track only. void Display_Track () Display the Track. void Modify_Position (uint8_t _u8_position, uint8_t _u8_player_number, bool bool_remove)  void Move_Token (uint8_t _u8_player_nr, uint8_t _u8_remove_position, uint8_t _u8_add_position) Move a Token. void Set_Colors (uint8_t _u8_player_nr, uint16_t _u16_bright_color, uint16_t _u16_dark_color) Set the Colors of the player. cla_display (uint8_t _u8_matrix_a, uint8_t u8_matrix_b, uint8_t u8_matrix_c, uint8_t u8_matrix_clk, uint8_t u8_lat, uint8_t u8_matrix_oe) Constructor of the class."},{"location":"DeviceCode/classASL_1_1cla__display/#detailed-description","title":"Detailed Description","text":"<p>This class handles all the functions and parameters needed to display the game. </p>"},{"location":"DeviceCode/classASL_1_1cla__display/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"DeviceCode/classASL_1_1cla__display/#function-begin","title":"function Begin","text":"<p>Initial Setup. <pre><code>void ASL::cla_display::Begin () \n</code></pre></p> <p>This function must be called ONCE at the beginning of the Code </p>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-blink_is_on","title":"function Blink_Is_On","text":"<p>Is Blinking On? <pre><code>bool ASL::cla_display::Blink_Is_On () \n</code></pre></p> <p>Returns:</p> <p>true if blinking is on, false otherwise </p>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-blink_start","title":"function Blink_Start","text":"<p>Blink method. <pre><code>void ASL::cla_display::Blink_Start (\n    en_blink_mode _en_blink_mode,\n    int8_t _i8_blink_cycles,\n    en_blink_type _en_blink_type,\n    uint8_t _u8_blink_player_number,\n    int8_t _i8_blink_second_player,\n    uint8_t _u8_new_position=0,\n    bool _bool_occupied_flag=true,\n    uint8_t _u8_old_position=0\n) \n</code></pre></p> <p>This method can blink * a token to display possible Progress (token) * two tokens alternating in the color of two players (token_thrown)</p> <p>Parameters:</p> <ul> <li><code>_en_blink_mode</code> The mode of the blinking (fast/slow/off) </li> <li><code>_i8_blink_cycles</code> The number of cycles to blink (-1: infinite) </li> <li><code>_en_blink_type</code> The type of the blinking (token/token_thrown/starting_square/winner_animation) </li> <li><code>_u8_blink_player_number</code> The number of the player to blink. </li> <li><code>_i8_blink_second_player</code> The number of the second player to blink. </li> <li><code>_u8_new_position</code> new position of the token. default: 0. Different use in case of blink_type starting_square: Tokens at home, signaled by the bit position (1 &lt;&lt; tokennr -&gt; token is home).</li> <li><code>_bool_occupied_flag</code> flag used in token mode to determine the color to alternate the new position to. default: true</li> <li><code>_u8_old_position</code> old position of the token. default: 0 </li> </ul>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-blink_stop","title":"function Blink_Stop","text":"<pre><code>void ASL::cla_display::Blink_Stop () \n</code></pre>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-blink_update","title":"function Blink_Update","text":"<p>Update the Blink state. <pre><code>bool ASL::cla_display::Blink_Update (\n    bool _bool_isr_active\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>_bool_isr_active</code> flag to determine if the function is called from an interupt service routine. </li> </ul> <p>Returns:</p> <p>true if the Blinking wasn't executed due to it possibly taking too long. </p>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-display_char","title":"function Display_Char","text":"<p>Display the Word. <pre><code>void ASL::cla_display::Display_Char (\n    char _ch_first_letter=' ',\n    char _ch_second_letter=' ',\n    char _ch_third_letter=' '\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>_ch_first_letter</code> The first letter of the word to display. default: ' '</li> <li><code>_ch_second_letter</code> The second letter of the word to display. default: ' ' </li> </ul>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-display_clear_right","title":"function Display_Clear_Right","text":"<pre><code>void ASL::cla_display::Display_Clear_Right () \n</code></pre>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-display_current_player","title":"function Display_Current_Player","text":"<p>Display the Current Player. <pre><code>void ASL::cla_display::Display_Current_Player (\n    int8_t _i8_current_player_number,\n    int8_t _i8_tokens_at_home=-1\n) \n</code></pre></p> <p>This method can display the current player on the matrix.</p> <p>Parameters:</p> <ul> <li><code>_i8_current_player_number</code> The number of the current player. </li> <li><code>_u8_tokens_at_home</code> Tokens at home, signaled by the bit position (1 &lt;&lt; tokennr -&gt; token is home). default: -1 (don't animate) </li> </ul>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-display_dice","title":"function Display_Dice","text":"<p>Display the dice. <pre><code>void ASL::cla_display::Display_Dice (\n    uint8_t _u8_dice_value,\n    uint8_t _u8_dice_roll_counter,\n    int8_t _i8_current_player_number,\n    bool _bool_animate=true\n) \n</code></pre></p> <p>Display the Dice on the matrix. when Set to animate, it will play a small animation. The animation uses a simple delay instead of interupts, since the program is not supposed to keep running while the animation is played.</p> <p>Parameters:</p> <ul> <li><code>_u8_dice_value</code> The value to be displayed. </li> <li><code>_u8_dice_roll_counter</code> The number of the current roll. </li> <li><code>_i8_current_player_number</code> The number of the current player. </li> <li><code>_bool_animate</code> flag to determine if the dice should be animated. should be handled with care as it uses Delay. default: true </li> </ul>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-display_players","title":"function Display_Players","text":"<p>Display the Players all in home. <pre><code>void ASL::cla_display::Display_Players (\n    uint8_t _u8_player_quantity,\n    bool _bool_tokens_at_home=true\n) \n</code></pre></p> <p>This method is supposed to be called when setting the Game up. It displays the number of players that are currently chosen.</p> <p>Parameters:</p> <ul> <li><code>_u8_player_quantity</code> The number of Players to be displayed. </li> </ul>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-display_progress","title":"function Display_Progress","text":"<p>Display the Progress This method can display the progress of the Player. <pre><code>void ASL::cla_display::Display_Progress (\n    int8_t _i8_current_player_number,\n    uint8_t _u8_progress\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>_i8_current_player_number</code> The number of the current player. </li> <li><code>_u8_progress</code> The progress of the player. (0:28) </li> </ul>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-display_restore","title":"function Display_Restore","text":"<pre><code>void ASL::cla_display::Display_Restore () \n</code></pre>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-display_track","title":"function Display_Track","text":"<pre><code>void ASL::cla_display::Display_Track () \n</code></pre>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-modify_position","title":"function Modify_Position","text":"<pre><code>void ASL::cla_display::Modify_Position (\n    uint8_t _u8_position,\n    uint8_t _u8_player_number,\n    bool bool_remove\n) \n</code></pre>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-move_token","title":"function Move_Token","text":"<p>Move a Token. <pre><code>void ASL::cla_display::Move_Token (\n    uint8_t _u8_player_nr,\n    uint8_t _u8_remove_position,\n    uint8_t _u8_add_position\n) \n</code></pre></p> <p>This method can move a token.</p> <p>Parameters:</p> <ul> <li><code>_u8_player_number</code> chosen player </li> <li><code>_u8_old_position</code> old position of the token </li> <li><code>_u8_new_position</code> new position of the token </li> </ul>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-set_colors","title":"function Set_Colors","text":"<p>Set the Colors of the player. <pre><code>void ASL::cla_display::Set_Colors (\n    uint8_t _u8_player_nr,\n    uint16_t _u16_bright_color,\n    uint16_t _u16_dark_color\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>_u8_player_nr</code> Number of the Player (0:3) </li> <li><code>_u16_bright_color</code> Bright Color for the Player </li> <li><code>_u16_dark_color</code> Dark Color for the Player </li> </ul>"},{"location":"DeviceCode/classASL_1_1cla__display/#function-cla_display","title":"function cla_display","text":"<pre><code>ASL::cla_display::cla_display (\n    uint8_t _u8_matrix_a,\n    uint8_t u8_matrix_b,\n    uint8_t u8_matrix_c,\n    uint8_t u8_matrix_clk,\n    uint8_t u8_lat,\n    uint8_t u8_matrix_oe\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/lib/ASL/ASL.hpp</code></p>"},{"location":"DeviceCode/namespaceLOGIC/","title":"Namespace LOGIC","text":"<p>Namespace List &gt; LOGIC</p>"},{"location":"DeviceCode/namespaceLOGIC/#classes","title":"Classes","text":"Type Name class cla_computer_player This class represents a computer opponent in the game. It provides methods for automatic movement of tokens. It is derived from the cla_player . class cla_manual_player This class represents a manual player in a game. It is derived from the cla_player class. class cla_player This class represents a player in the game. It provides methods for moving tokens and checking the status of the player. It is an abstract class and has two derived classes: cla_computer_player andcla_manual_player . class cla_session The cla_session class is the main class of the game logic. It initializes the players with their methods and it provides essential methods for the game logic."},{"location":"DeviceCode/namespaceLOGIC/#public-types","title":"Public Types","text":"Type Name enum mode enum status"},{"location":"DeviceCode/namespaceLOGIC/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"DeviceCode/namespaceLOGIC/#enum-mode","title":"enum mode","text":"<pre><code>enum LOGIC::mode {\n    Student = 0,\n    Professor = 1\n};\n</code></pre>"},{"location":"DeviceCode/namespaceLOGIC/#enum-status","title":"enum status","text":"<pre><code>enum LOGIC::status {\n    Start = 0,\n    Start_Track,\n    Start_Finished,\n    Start_Track_Finished,\n    Error,\n    Track,\n    Finished,\n    Track_Finished\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/lib/Game_Logic/logic.cpp</code></p>"},{"location":"DeviceCode/classLOGIC_1_1cla__computer__player/","title":"Class LOGIC::cla_computer_player","text":"<p>ClassList &gt; LOGIC &gt; cla_computer_player</p> <p>This class represents a computer opponent in the game. It provides methods for automatic movement of tokens. It is derived from the cla_player .</p> <ul> <li><code>#include &lt;logic.hpp&gt;</code></li> </ul> <p>Inherits the following classes: LOGIC::cla_player</p>"},{"location":"DeviceCode/classLOGIC_1_1cla__computer__player/#public-functions","title":"Public Functions","text":"Type Name virtual int8_t Auto_Move (uint8_t _u8_dice_value, bool &amp; _bool_occupied_flag, uint8_t &amp; _u8_old_position) overrideAutomatic movement for a computer opponent. virtual bool Is_Computer () override constChecks if the player is a computer opponent. cla_computer_player (uint8_t _u8_player_id, uint8_t _u8_start_position, uint8_t _u8_computer_quantity, cla_session * _obj_my_session, mode _en_mode) Constructor for the cla_computer_player class."},{"location":"DeviceCode/classLOGIC_1_1cla__computer__player/#public-functions-inherited-from-logiccla_player","title":"Public Functions inherited from LOGIC::cla_player","text":"<p>See LOGIC::cla_player</p> Type Name virtual int8_t Auto_Move (uint8_t _u8_dice_value, bool &amp; _bool_occupied_flag, uint8_t &amp; _u8_old_position)  uint8_t Calculate_Possible_Position (uint8_t _u8_token_number, uint8_t _u8_dice_value) Calculates the possible position of a token. uint8_t Get_Player_Progress () Returns the overall progress of the player (Value between 1-28). status Get_Player_Status () Outputs the status of player. uint8_t Get_Start_Position () Returns the starting position of the player. uint8_t Get_Token_Position (uint8_t _u8_token_number) Returns the current position of a token. uint8_t Get_Token_Progress (uint8_t _u8_token_number) Returns the progress of a token on the track. virtual bool Is_Computer () const = 0Checks if the player is a computer opponent. int8_t Is_Start_Field_Occupied_By_Own_Token () Checks if the starting square is occupied by own token while other tokens are home. uint8_t Move_Token (uint8_t _u8_token_number, uint8_t _u8_dice_value) Moves a token on the track. uint8_t Set_Token_Position (uint8_t _u8_token_number, uint8_t _u8_new_position) Changes the position of a token. cla_player (uint8_t _u8_player_id, uint8_t _u8_start_position, uint8_t _u8_computer_quantity, cla_session * _obj_my_session) Constructor for the cla_player class."},{"location":"DeviceCode/classLOGIC_1_1cla__computer__player/#protected-attributes","title":"Protected Attributes","text":"Type Name mode en_mode The mode of the computer opponent."},{"location":"DeviceCode/classLOGIC_1_1cla__computer__player/#protected-attributes-inherited-from-logiccla_player","title":"Protected Attributes inherited from LOGIC::cla_player","text":"<p>See LOGIC::cla_player</p> Type Name cla_session * obj_my_session Pointer to the associated session. uint8_t u8_player_id The id of the player. uint8_t u8_start_position The starting position of the player. uint8_t u8_token_position The positions of the player's four tokens."},{"location":"DeviceCode/classLOGIC_1_1cla__computer__player/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"DeviceCode/classLOGIC_1_1cla__computer__player/#function-auto_move","title":"function Auto_Move","text":"<p>Automatic movement for a computer opponent. <pre><code>virtual int8_t LOGIC::cla_computer_player::Auto_Move (\n    uint8_t _u8_dice_value,\n    bool &amp; _bool_occupied_flag,\n    uint8_t &amp; _u8_old_position\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>_u8_dice_value</code> The value of the rolled dice. </li> <li><code>&amp;_bool_occupied_flag</code> Reference to a variable to store the occupied flag. </li> <li><code>&amp;_u8_old_position</code> Reference to a variable to store the old position. </li> </ul> <p>Returns:</p> <p>The token that was automatically moved. </p> <p>Implements LOGIC::cla_player::Auto_Move</p>"},{"location":"DeviceCode/classLOGIC_1_1cla__computer__player/#function-is_computer","title":"function Is_Computer","text":"<p>Checks if the player is a computer opponent. <pre><code>inline virtual bool LOGIC::cla_computer_player::Is_Computer () override const\n</code></pre></p> <p>Returns:</p> <p>true if the player is a computer opponent, false otherwise. </p> <p>Implements LOGIC::cla_player::Is_Computer</p>"},{"location":"DeviceCode/classLOGIC_1_1cla__computer__player/#function-cla_computer_player","title":"function cla_computer_player","text":"<p>Constructor for the cla_computer_player class. <pre><code>LOGIC::cla_computer_player::cla_computer_player (\n    uint8_t _u8_player_id,\n    uint8_t _u8_start_position,\n    uint8_t _u8_computer_quantity,\n    cla_session * _obj_my_session,\n    mode _en_mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>_u8_player_id</code> The ID of the player. </li> <li><code>_u8_start_position</code> The individual starting position of the player. </li> <li><code>_u8_computer_quantity</code> The number of computer controlled players. </li> <li><code>_u8_mode</code> The mode of the computer opponent. </li> </ul>"},{"location":"DeviceCode/classLOGIC_1_1cla__computer__player/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"DeviceCode/classLOGIC_1_1cla__computer__player/#variable-en_mode","title":"variable en_mode","text":"<pre><code>mode LOGIC::cla_computer_player::en_mode;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/lib/Game_Logic/logic.hpp</code></p>"},{"location":"DeviceCode/classLOGIC_1_1cla__manual__player/","title":"Class LOGIC::cla_manual_player","text":"<p>ClassList &gt; LOGIC &gt; cla_manual_player</p> <p>This class represents a manual player in a game. It is derived from the cla_player class.</p> <ul> <li><code>#include &lt;logic.hpp&gt;</code></li> </ul> <p>Inherits the following classes: LOGIC::cla_player</p>"},{"location":"DeviceCode/classLOGIC_1_1cla__manual__player/#public-functions","title":"Public Functions","text":"Type Name virtual bool Is_Computer () override constChecks if the player is a computer opponent. cla_manual_player (uint8_t _u8_player_id, uint8_t _u8_start_position, uint8_t _u8_computer_quantity, cla_session * _obj_my_session) Constructor for the cla_manual_player class."},{"location":"DeviceCode/classLOGIC_1_1cla__manual__player/#public-functions-inherited-from-logiccla_player","title":"Public Functions inherited from LOGIC::cla_player","text":"<p>See LOGIC::cla_player</p> Type Name virtual int8_t Auto_Move (uint8_t _u8_dice_value, bool &amp; _bool_occupied_flag, uint8_t &amp; _u8_old_position)  uint8_t Calculate_Possible_Position (uint8_t _u8_token_number, uint8_t _u8_dice_value) Calculates the possible position of a token. uint8_t Get_Player_Progress () Returns the overall progress of the player (Value between 1-28). status Get_Player_Status () Outputs the status of player. uint8_t Get_Start_Position () Returns the starting position of the player. uint8_t Get_Token_Position (uint8_t _u8_token_number) Returns the current position of a token. uint8_t Get_Token_Progress (uint8_t _u8_token_number) Returns the progress of a token on the track. virtual bool Is_Computer () const = 0Checks if the player is a computer opponent. int8_t Is_Start_Field_Occupied_By_Own_Token () Checks if the starting square is occupied by own token while other tokens are home. uint8_t Move_Token (uint8_t _u8_token_number, uint8_t _u8_dice_value) Moves a token on the track. uint8_t Set_Token_Position (uint8_t _u8_token_number, uint8_t _u8_new_position) Changes the position of a token. cla_player (uint8_t _u8_player_id, uint8_t _u8_start_position, uint8_t _u8_computer_quantity, cla_session * _obj_my_session) Constructor for the cla_player class."},{"location":"DeviceCode/classLOGIC_1_1cla__manual__player/#protected-attributes-inherited-from-logiccla_player","title":"Protected Attributes inherited from LOGIC::cla_player","text":"<p>See LOGIC::cla_player</p> Type Name cla_session * obj_my_session Pointer to the associated session. uint8_t u8_player_id The id of the player. uint8_t u8_start_position The starting position of the player. uint8_t u8_token_position The positions of the player's four tokens."},{"location":"DeviceCode/classLOGIC_1_1cla__manual__player/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"DeviceCode/classLOGIC_1_1cla__manual__player/#function-is_computer","title":"function Is_Computer","text":"<p>Checks if the player is a computer opponent. <pre><code>inline virtual bool LOGIC::cla_manual_player::Is_Computer () override const\n</code></pre></p> <p>Returns:</p> <p>true if the player is a computer opponent, false otherwise. </p> <p>Implements LOGIC::cla_player::Is_Computer</p>"},{"location":"DeviceCode/classLOGIC_1_1cla__manual__player/#function-cla_manual_player","title":"function cla_manual_player","text":"<pre><code>LOGIC::cla_manual_player::cla_manual_player (\n    uint8_t _u8_player_id,\n    uint8_t _u8_start_position,\n    uint8_t _u8_computer_quantity,\n    cla_session * _obj_my_session\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/lib/Game_Logic/logic.hpp</code></p>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/","title":"Class LOGIC::cla_player","text":"<p>ClassList &gt; LOGIC &gt; cla_player</p> <p>This class represents a player in the game. It provides methods for moving tokens and checking the status of the player. It is an abstract class and has two derived classes: cla_computer_player andcla_manual_player .</p> <ul> <li><code>#include &lt;logic.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: LOGIC::cla_computer_player,  LOGIC::cla_manual_player</p>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#public-functions","title":"Public Functions","text":"Type Name virtual int8_t Auto_Move (uint8_t _u8_dice_value, bool &amp; _bool_occupied_flag, uint8_t &amp; _u8_old_position)  uint8_t Calculate_Possible_Position (uint8_t _u8_token_number, uint8_t _u8_dice_value) Calculates the possible position of a token. uint8_t Get_Player_Progress () Returns the overall progress of the player (Value between 1-28). status Get_Player_Status () Outputs the status of player. uint8_t Get_Start_Position () Returns the starting position of the player. uint8_t Get_Token_Position (uint8_t _u8_token_number) Returns the current position of a token. uint8_t Get_Token_Progress (uint8_t _u8_token_number) Returns the progress of a token on the track. virtual bool Is_Computer () const = 0Checks if the player is a computer opponent. int8_t Is_Start_Field_Occupied_By_Own_Token () Checks if the starting square is occupied by own token while other tokens are home. uint8_t Move_Token (uint8_t _u8_token_number, uint8_t _u8_dice_value) Moves a token on the track. uint8_t Set_Token_Position (uint8_t _u8_token_number, uint8_t _u8_new_position) Changes the position of a token. cla_player (uint8_t _u8_player_id, uint8_t _u8_start_position, uint8_t _u8_computer_quantity, cla_session * _obj_my_session) Constructor for the cla_player class."},{"location":"DeviceCode/classLOGIC_1_1cla__player/#protected-attributes","title":"Protected Attributes","text":"Type Name cla_session * obj_my_session Pointer to the associated session. uint8_t u8_player_id The id of the player. uint8_t u8_start_position The starting position of the player. uint8_t u8_token_position The positions of the player's four tokens."},{"location":"DeviceCode/classLOGIC_1_1cla__player/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"DeviceCode/classLOGIC_1_1cla__player/#function-auto_move","title":"function Auto_Move","text":"<pre><code>virtual int8_t LOGIC::cla_player::Auto_Move (\n    uint8_t _u8_dice_value,\n    bool &amp; _bool_occupied_flag,\n    uint8_t &amp; _u8_old_position\n) \n</code></pre>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#function-calculate_possible_position","title":"function Calculate_Possible_Position","text":"<p>Calculates the possible position of a token. <pre><code>uint8_t LOGIC::cla_player::Calculate_Possible_Position (\n    uint8_t _u8_token_number,\n    uint8_t _u8_dice_value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>_u8_token_number</code> The token number. </li> <li><code>_u8_dice_value</code> The value of the rolled dice. </li> </ul> <p>Returns:</p> <p>The calculated position of the token. </p>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#function-get_player_progress","title":"function Get_Player_Progress","text":"<p>Returns the overall progress of the player (Value between 1-28). <pre><code>uint8_t LOGIC::cla_player::Get_Player_Progress () \n</code></pre></p> <p>Returns:</p> <p>The overall progress of the player on the track. </p>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#function-get_player_status","title":"function Get_Player_Status","text":"<p>Outputs the status of player. <pre><code>status LOGIC::cla_player::Get_Player_Status () \n</code></pre></p> <p>Returns:</p> <p>The status of the player. </p>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#function-get_start_position","title":"function Get_Start_Position","text":"<pre><code>uint8_t LOGIC::cla_player::Get_Start_Position () \n</code></pre>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#function-get_token_position","title":"function Get_Token_Position","text":"<p>Returns the current position of a token. <pre><code>uint8_t LOGIC::cla_player::Get_Token_Position (\n    uint8_t _u8_token_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>_u8_token_number</code> The token number. </li> </ul> <p>Returns:</p> <p>The current position of the token. </p>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#function-get_token_progress","title":"function Get_Token_Progress","text":"<p>Returns the progress of a token on the track. <pre><code>uint8_t LOGIC::cla_player::Get_Token_Progress (\n    uint8_t _u8_token_number\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>_u8_token_number</code> The token number. </li> </ul> <p>Returns:</p> <p>The progress of the token on the track. </p>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#function-is_computer","title":"function Is_Computer","text":"<p>Checks if the player is a computer opponent. <pre><code>virtual bool LOGIC::cla_player::Is_Computer () const = 0\n</code></pre></p> <p>Returns:</p> <p>true if the player is a computer opponent, false otherwise. </p>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#function-is_start_field_occupied_by_own_token","title":"function Is_Start_Field_Occupied_By_Own_Token","text":"<p>Checks if the starting square is occupied by own token while other tokens are home. <pre><code>int8_t LOGIC::cla_player::Is_Start_Field_Occupied_By_Own_Token () \n</code></pre></p> <p>Returns:</p> <p>The token number that must be moved </p>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#function-move_token","title":"function Move_Token","text":"<p>Moves a token on the track. <pre><code>uint8_t LOGIC::cla_player::Move_Token (\n    uint8_t _u8_token_number,\n    uint8_t _u8_dice_value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>_u8_token_number</code> The token number. </li> <li><code>_u8_dice_value</code> The value of the rolled dice. </li> </ul> <p>Returns:</p> <p>The new position of the token. </p>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#function-set_token_position","title":"function Set_Token_Position","text":"<p>Changes the position of a token. <pre><code>uint8_t LOGIC::cla_player::Set_Token_Position (\n    uint8_t _u8_token_number,\n    uint8_t _u8_new_position\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>_u8_token_number</code> The token number. </li> <li><code>_u8_new_position</code> The new position of the token. </li> </ul> <p>Returns:</p> <p>The new position of the token. </p>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#function-cla_player","title":"function cla_player","text":"<p>Constructor for the cla_player class. <pre><code>LOGIC::cla_player::cla_player (\n    uint8_t _u8_player_id,\n    uint8_t _u8_start_position,\n    uint8_t _u8_computer_quantity,\n    cla_session * _obj_my_session\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>_u8_player_id</code> The ID of the player. </li> <li><code>_u8_start_position</code> The individual starting position of the player. </li> <li><code>_u8_computer_quantity</code> The number of computer controlled players. </li> <li><code>_obj_my_session</code> Pointer to the associated session. </li> </ul>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"DeviceCode/classLOGIC_1_1cla__player/#variable-obj_my_session","title":"variable obj_my_session","text":"<pre><code>cla_session* LOGIC::cla_player::obj_my_session;\n</code></pre>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#variable-u8_player_id","title":"variable u8_player_id","text":"<pre><code>uint8_t LOGIC::cla_player::u8_player_id;\n</code></pre>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#variable-u8_start_position","title":"variable u8_start_position","text":"<pre><code>uint8_t LOGIC::cla_player::u8_start_position;\n</code></pre>"},{"location":"DeviceCode/classLOGIC_1_1cla__player/#variable-u8_token_position","title":"variable u8_token_position","text":"<pre><code>uint8_t LOGIC::cla_player::u8_token_position[4];\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/lib/Game_Logic/logic.hpp</code></p>"},{"location":"DeviceCode/classLOGIC_1_1cla__session/","title":"Class LOGIC::cla_session","text":"<p>ClassList &gt; LOGIC &gt; cla_session</p> <p>The cla_session class is the main class of the game logic. It initializes the players with their methods and it provides essential methods for the game logic.</p> <ul> <li><code>#include &lt;logic.hpp&gt;</code></li> </ul>"},{"location":"DeviceCode/classLOGIC_1_1cla__session/#public-attributes","title":"Public Attributes","text":"Type Name cla_player * array_players Array of pointers to the players. uint8_t u8_is_occupied_player_id uint8_t u8_is_occupied_token_number"},{"location":"DeviceCode/classLOGIC_1_1cla__session/#public-functions","title":"Public Functions","text":"Type Name uint8_t Get_Computer_Quantity () Returns the number of computer players. uint8_t Get_Player_Quantity () Returns the number of players. bool Is_Occupied (uint8_t &amp; _u8_is_occupied_player_id, uint8_t &amp; _u8_is_occupied_token_number, uint8_t _u8_affected_track_position) Checks if the position on the map is occupied. bool Return_Home (uint8_t _u8_affected_track_position) Returns a token to its home position. cla_session (uint8_t _u8_player_quantity, uint8_t _u8_computer_quantity, mode _en_mode) Constructor for the cla_session class."},{"location":"DeviceCode/classLOGIC_1_1cla__session/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"DeviceCode/classLOGIC_1_1cla__session/#variable-array_players","title":"variable array_players","text":"<pre><code>cla_player* LOGIC::cla_session::array_players[4];\n</code></pre>"},{"location":"DeviceCode/classLOGIC_1_1cla__session/#variable-u8_is_occupied_player_id","title":"variable u8_is_occupied_player_id","text":"<pre><code>uint8_t LOGIC::cla_session::u8_is_occupied_player_id;\n</code></pre> <p>The ID of the player at the occupied track position. </p>"},{"location":"DeviceCode/classLOGIC_1_1cla__session/#variable-u8_is_occupied_token_number","title":"variable u8_is_occupied_token_number","text":"<pre><code>uint8_t LOGIC::cla_session::u8_is_occupied_token_number;\n</code></pre> <p>The token number at the occupied track position. </p>"},{"location":"DeviceCode/classLOGIC_1_1cla__session/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"DeviceCode/classLOGIC_1_1cla__session/#function-get_computer_quantity","title":"function Get_Computer_Quantity","text":"<pre><code>uint8_t LOGIC::cla_session::Get_Computer_Quantity () \n</code></pre>"},{"location":"DeviceCode/classLOGIC_1_1cla__session/#function-get_player_quantity","title":"function Get_Player_Quantity","text":"<pre><code>uint8_t LOGIC::cla_session::Get_Player_Quantity () \n</code></pre>"},{"location":"DeviceCode/classLOGIC_1_1cla__session/#function-is_occupied","title":"function Is_Occupied","text":"<p>Checks if the position on the map is occupied. <pre><code>bool LOGIC::cla_session::Is_Occupied (\n    uint8_t &amp; _u8_is_occupied_player_id,\n    uint8_t &amp; _u8_is_occupied_token_number,\n    uint8_t _u8_affected_track_position\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>&amp;u8_is_occupied_player_id</code> Reference to variable to store the player ID of the occupied track position. </li> <li><code>&amp;u8_is_occupied_token_number</code> Reference to variable to store the token number of the occupied track position. </li> <li><code>_u8_affected_track_position</code> The track position to check. </li> </ul> <p>Returns:</p> <p>true if occupied, false otherwise. </p>"},{"location":"DeviceCode/classLOGIC_1_1cla__session/#function-return_home","title":"function Return_Home","text":"<p>Returns a token to its home position. <pre><code>bool LOGIC::cla_session::Return_Home (\n    uint8_t _u8_affected_track_position\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>_u8_affected_track_position</code> The affected track position. </li> </ul> <p>Returns:</p> <p>true if the token is successfully returned home, false otherwise. </p>"},{"location":"DeviceCode/classLOGIC_1_1cla__session/#function-cla_session","title":"function cla_session","text":"<p>Constructor for the cla_session class. <pre><code>LOGIC::cla_session::cla_session (\n    uint8_t _u8_player_quantity,\n    uint8_t _u8_computer_quantity,\n    mode _en_mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>_u8_player_quantity</code> Number of all players. </li> <li><code>_u8_computer_quantity</code> Number of computer-controlled players. </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/lib/Game_Logic/logic.hpp</code></p>"},{"location":"DeviceCode/dir_6774b76becf5c1eba00b38f86dafd5a0/","title":"Dir Engineering","text":"<p>FileList &gt; Engineering</p>"},{"location":"DeviceCode/dir_6774b76becf5c1eba00b38f86dafd5a0/#directories","title":"Directories","text":"Type Name dir COD_ENG_OUT_arduino_code <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/</code></p>"},{"location":"DeviceCode/dir_e46236678326602fb51a33a9a20e1fb4/","title":"Dir COD_ENG_OUT_arduino_code","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code</p>"},{"location":"DeviceCode/dir_e46236678326602fb51a33a9a20e1fb4/#directories","title":"Directories","text":"Type Name dir include dir lib dir src dir test <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/</code></p>"},{"location":"DeviceCode/dir_32fda5728acd4db3cc42f60aad9a9fcc/","title":"Dir include","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; include</p>"},{"location":"DeviceCode/dir_32fda5728acd4db3cc42f60aad9a9fcc/#files","title":"Files","text":"Type Name file defines.hpp This file contains all the defines for the project. <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/include/</code></p>"},{"location":"DeviceCode/defines_8hpp/","title":"File defines.hpp","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; include &gt; defines.hpp</p> <p>Go to the source code of this file</p> <p>This file contains all the defines for the project. More...</p>"},{"location":"DeviceCode/defines_8hpp/#macros","title":"Macros","text":"Type Name define A  A0 define ANIMATION_SPEED_COMPUTER  15625 define ANIMATION_SPEED_DICE  3125 define ANIMATION_SPEED_MOVE  6250 define B  A1 define BLINK_CYCLES_OCCUPIED_TOKEN  3 define BLINK_CYCLES_TOKEN  -1 define BLINK_CYCLES_WINNER_ANIMATION  -1 define BLUE_BRIGHT  0x001f define BLUE_DARK  0x0002 define C  A2 define CLK  11 define DEBOUNCE_TIME  0x1000 define DEBUG  false define DICE_MODE  0 define DICE_ROLLS_AT_SIX  1 define DICE_ROLLS_AT_START  3 define DICE_ROLLS_NORMAL  1 define FAST_BLINK  7813 define GREEN_BRIGHT  0x7e0 define GREEN_DARK  0xa0 define INITIAL_BOOL_BLINK_FLAG  false define INITIAL_COMPUTER_MODE  LOGIC::Student define INITIAL_COMPUTER_QUANTITY  0 define INITIAL_CURRENT_PLAYER_NUMBER  0 define INITIAL_CURRENT_TOKEN_NUMBER  0 define INITIAL_DICE_ROLL_COUNTER  DICE_ROLLS_AT_START define INITIAL_DICE_VALUE  0 define INITIAL_PLAYER_QUANTITY  2 define LAT  A3 define OE  12 define RED_BRIGHT  0xf800 define RED_DARK  0x1000 define SLOW_BLINK  15625 define TIMING_DEBUG  false define TIMING_DEBUG_COUNT_TO  100 define TIMING_DEBUG_INTERN  0 define WHITE_BRIGHT  0xffff define YELLOW_BRIGHT  0xffe0 define YELLOW_DARK  0x10a0"},{"location":"DeviceCode/defines_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Use this file to define all the ports, colors, animation speeds, initial values and debug modes. </p>"},{"location":"DeviceCode/defines_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"DeviceCode/defines_8hpp/#define-a","title":"define A","text":"<pre><code>#define A A0\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-animation_speed_computer","title":"define ANIMATION_SPEED_COMPUTER","text":"<pre><code>#define ANIMATION_SPEED_COMPUTER 15625\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-animation_speed_dice","title":"define ANIMATION_SPEED_DICE","text":"<pre><code>#define ANIMATION_SPEED_DICE 3125\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-animation_speed_move","title":"define ANIMATION_SPEED_MOVE","text":"<pre><code>#define ANIMATION_SPEED_MOVE 6250\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-b","title":"define B","text":"<pre><code>#define B A1\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-blink_cycles_occupied_token","title":"define BLINK_CYCLES_OCCUPIED_TOKEN","text":"<pre><code>#define BLINK_CYCLES_OCCUPIED_TOKEN 3\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-blink_cycles_token","title":"define BLINK_CYCLES_TOKEN","text":"<pre><code>#define BLINK_CYCLES_TOKEN -1\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-blink_cycles_winner_animation","title":"define BLINK_CYCLES_WINNER_ANIMATION","text":"<pre><code>#define BLINK_CYCLES_WINNER_ANIMATION -1\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-blue_bright","title":"define BLUE_BRIGHT","text":"<pre><code>#define BLUE_BRIGHT 0x001f\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-blue_dark","title":"define BLUE_DARK","text":"<pre><code>#define BLUE_DARK 0x0002\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-c","title":"define C","text":"<pre><code>#define C A2\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-clk","title":"define CLK","text":"<pre><code>#define CLK 11\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-debounce_time","title":"define DEBOUNCE_TIME","text":"<pre><code>#define DEBOUNCE_TIME 0x1000\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-debug","title":"define DEBUG","text":"<pre><code>#define DEBUG false\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-dice_mode","title":"define DICE_MODE","text":"<pre><code>#define DICE_MODE 0\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-dice_rolls_at_six","title":"define DICE_ROLLS_AT_SIX","text":"<pre><code>#define DICE_ROLLS_AT_SIX 1\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-dice_rolls_at_start","title":"define DICE_ROLLS_AT_START","text":"<pre><code>#define DICE_ROLLS_AT_START 3\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-dice_rolls_normal","title":"define DICE_ROLLS_NORMAL","text":"<pre><code>#define DICE_ROLLS_NORMAL 1\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-fast_blink","title":"define FAST_BLINK","text":"<pre><code>#define FAST_BLINK 7813\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-green_bright","title":"define GREEN_BRIGHT","text":"<pre><code>#define GREEN_BRIGHT 0x7e0\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-green_dark","title":"define GREEN_DARK","text":"<pre><code>#define GREEN_DARK 0xa0\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-initial_bool_blink_flag","title":"define INITIAL_BOOL_BLINK_FLAG","text":"<pre><code>#define INITIAL_BOOL_BLINK_FLAG false\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-initial_computer_mode","title":"define INITIAL_COMPUTER_MODE","text":"<pre><code>#define INITIAL_COMPUTER_MODE LOGIC::Student\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-initial_computer_quantity","title":"define INITIAL_COMPUTER_QUANTITY","text":"<pre><code>#define INITIAL_COMPUTER_QUANTITY 0\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-initial_current_player_number","title":"define INITIAL_CURRENT_PLAYER_NUMBER","text":"<pre><code>#define INITIAL_CURRENT_PLAYER_NUMBER 0\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-initial_current_token_number","title":"define INITIAL_CURRENT_TOKEN_NUMBER","text":"<pre><code>#define INITIAL_CURRENT_TOKEN_NUMBER 0\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-initial_dice_roll_counter","title":"define INITIAL_DICE_ROLL_COUNTER","text":"<pre><code>#define INITIAL_DICE_ROLL_COUNTER DICE_ROLLS_AT_START\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-initial_dice_value","title":"define INITIAL_DICE_VALUE","text":"<pre><code>#define INITIAL_DICE_VALUE 0\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-initial_player_quantity","title":"define INITIAL_PLAYER_QUANTITY","text":"<pre><code>#define INITIAL_PLAYER_QUANTITY 2\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-lat","title":"define LAT","text":"<pre><code>#define LAT A3\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-oe","title":"define OE","text":"<pre><code>#define OE 12\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-red_bright","title":"define RED_BRIGHT","text":"<pre><code>#define RED_BRIGHT 0xf800\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-red_dark","title":"define RED_DARK","text":"<pre><code>#define RED_DARK 0x1000\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-slow_blink","title":"define SLOW_BLINK","text":"<pre><code>#define SLOW_BLINK 15625\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-timing_debug","title":"define TIMING_DEBUG","text":"<pre><code>#define TIMING_DEBUG false\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-timing_debug_count_to","title":"define TIMING_DEBUG_COUNT_TO","text":"<pre><code>#define TIMING_DEBUG_COUNT_TO 100\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-timing_debug_intern","title":"define TIMING_DEBUG_INTERN","text":"<pre><code>#define TIMING_DEBUG_INTERN 0\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-white_bright","title":"define WHITE_BRIGHT","text":"<pre><code>#define WHITE_BRIGHT 0xffff\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-yellow_bright","title":"define YELLOW_BRIGHT","text":"<pre><code>#define YELLOW_BRIGHT 0xffe0\n</code></pre>"},{"location":"DeviceCode/defines_8hpp/#define-yellow_dark","title":"define YELLOW_DARK","text":"<pre><code>#define YELLOW_DARK 0x10a0\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/include/defines.hpp</code></p>"},{"location":"DeviceCode/defines_8hpp_source/","title":"File defines.hpp","text":"<p>File List &gt; COD_ENG_OUT_arduino_code &gt; include &gt; defines.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef DEFINES_HPP\n#define DEFINES_HPP\n\n// Define all the Ports here:\n#define CLK 11 // MUST be on PORTB! (Use pin 11 on Mega)\n#define LAT A3\n#define OE 12\n#define A A0\n#define B A1\n#define C A2\n\n// define all the colors\n#define RED_BRIGHT 0xf800\n#define RED_DARK 0x1000\n#define GREEN_BRIGHT 0x7e0\n#define GREEN_DARK 0xa0\n#define YELLOW_BRIGHT 0xffe0\n#define YELLOW_DARK 0x10a0\n#define BLUE_BRIGHT 0x001f\n#define BLUE_DARK 0x0002\n#define WHITE_BRIGHT 0xffff\n\n// Define Debounce time\n// -&gt; T of 0x1000 count cycles: 4096 * 0,000064s = 0,262144s\n#define DEBOUNCE_TIME 0x1000\n\n// See Calculation Excel for more information on the timing.\n#define FAST_BLINK 7813\n#define SLOW_BLINK 15625\n\n// Define Animation Speed\n#define ANIMATION_SPEED_COMPUTER 15625 // 15625 -&gt; 250ms\n#define ANIMATION_SPEED_DICE 3125      // 6250 -&gt; 100ms, repeated 20 times -&gt; 2s\n#define ANIMATION_SPEED_MOVE 6250      // 6250 -&gt; 100ms\n\n// Define cylce count\n#define BLINK_CYCLES_TOKEN -1\n#define BLINK_CYCLES_OCCUPIED_TOKEN 3\n#define BLINK_CYCLES_WINNER_ANIMATION -1\n\n// Define initial values\n#define INITIAL_DICE_VALUE 0\n#define INITIAL_DICE_ROLL_COUNTER DICE_ROLLS_AT_START\n#define INITIAL_COMPUTER_MODE LOGIC::Student\n#define INITIAL_PLAYER_QUANTITY 2\n#define INITIAL_COMPUTER_QUANTITY 0\n#define INITIAL_CURRENT_PLAYER_NUMBER 0\n#define INITIAL_CURRENT_TOKEN_NUMBER 0\n#define INITIAL_BOOL_BLINK_FLAG false\n\n// Other defines\n#define DICE_ROLLS_AT_START 3\n#define DICE_ROLLS_NORMAL 1\n#define DICE_ROLLS_AT_SIX 1\n\n// Define the Debug Flag\n#define DEBUG false\n#define TIMING_DEBUG false\n// 0 for off\n// 1 for ISR(INT4_vect)\n// 2 for ISR(INT5_vect)\n// 3 for ISR(TIMER3_COMPA_vect)\n// 4 for ISR(TIMER4_COMPA_vect)\n// 5 for ISR(TIMER5_COMPA_vect)\n// 6 for ISR in matrix library (Adafruit_GFX)\n// number 6 must be added individually to the library, as the library is\n// automatically loaded when compiling platformio project for the first time.\n#define TIMING_DEBUG_INTERN 0\n// number of interupts to measure before crash.\n#define TIMING_DEBUG_COUNT_TO 100\n// DICE_MODE 0: Normal, Random Dice\n//           1: Dice input via PORT L\n//           2: marked Dice using Array\n#define DICE_MODE 0\n#if DICE_MODE == 2\n#include \"../test/marked_dice.hpp\"\n#endif\n#endif\n</code></pre>"},{"location":"DeviceCode/dir_4020720c6a555fbd5bcbb296f9427588/","title":"Dir lib","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; lib</p>"},{"location":"DeviceCode/dir_4020720c6a555fbd5bcbb296f9427588/#directories","title":"Directories","text":"Type Name dir ASL dir Game_Logic <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/lib/</code></p>"},{"location":"DeviceCode/dir_9d6c7046ff27a423104698a469533c50/","title":"Dir ASL","text":"<p>FileList &gt; ASL</p>"},{"location":"DeviceCode/dir_9d6c7046ff27a423104698a469533c50/#files","title":"Files","text":"Type Name file ASL.cpp This file contains the implementation of the Applications Service Layer. file ASL.hpp This is the header file for the ASL library. <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/lib/ASL/</code></p>"},{"location":"DeviceCode/ASL_8cpp/","title":"File ASL.cpp","text":"<p>FileList &gt; ASL &gt; ASL.cpp</p> <p>Go to the source code of this file</p> <p>This file contains the implementation of the Applications Service Layer. More...</p> <ul> <li><code>#include &lt;ASL.hpp&gt;</code></li> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"DeviceCode/ASL_8cpp/#detailed-description","title":"Detailed Description","text":"<p>This file implements</p> <ul> <li>the cla_display class</li> <li>the ASL::Setup_Buttons() function</li> <li>the ASL::Setup_Dice() function</li> <li>the ASL::Roll_Dice() function</li> <li>the ASL::Delay_256() function </li> </ul> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/lib/ASL/ASL.cpp</code></p>"},{"location":"DeviceCode/ASL_8cpp_source/","title":"File ASL.cpp","text":"<p>File List &gt; ASL &gt; ASL.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;ASL.hpp&gt;\n#include &lt;Arduino.h&gt;\n\nASL::cla_display::cla_display(uint8_t _u8_matrix_a, uint8_t _u8_matrix_b,\n                              uint8_t _u8_matrix_c, uint8_t _u8_matrix_clk,\n                              uint8_t _u8_matrix_lat, uint8_t _u8_matrix_oe) {\n  u8_matrix_a = _u8_matrix_a;\n  u8_matrix_b = _u8_matrix_b;\n  u8_matrix_c = _u8_matrix_c;\n  u8_matrix_clk = _u8_matrix_clk;\n  u8_matrix_lat = _u8_matrix_lat;\n  u8_matrix_oe = _u8_matrix_oe;\n}\n\nvoid ASL::cla_display::Set_Colors(uint8_t _u8_player_nr,\n                                  uint16_t _u16_bright_color,\n                                  uint16_t _u16_dark_color) {\n  u16_player_color[_u8_player_nr][0] = _u16_bright_color;\n  u16_player_color[_u8_player_nr][1] = _u16_dark_color;\n}\n\nvoid ASL::cla_display::Begin() {\n  RGBmatrixPanel obj_matrix_no_pointer(u8_matrix_a, u8_matrix_b, u8_matrix_c,\n                                       u8_matrix_clk, u8_matrix_lat,\n                                       u8_matrix_oe, false);\n  obj_matrix_no_pointer.begin();\n  this-&gt;obj_matrix = &amp;obj_matrix_no_pointer;\n  // Set up starting board:\n  Display_Track();\n}\n\nvoid ASL::cla_display::Display_Track() {\n  for (uint8_t i = 0; i &lt; 40; i++) {\n    obj_matrix-&gt;drawPixel(u8_track_positions[i][1], u8_track_positions[i][2],\n                          u16_track_color);\n  }\n  obj_matrix-&gt;updateDisplay();\n}\n\nvoid ASL::cla_display::Display_Players(uint8_t _u8_player_quantity,\n                                       bool _bool_tokens_at_home) {\n  // Home Positions:\n  for (uint8_t i = 0; i &lt; 4; i++) {\n    for (uint8_t j = 0; j &lt; 4; j++) {\n      if (_u8_player_quantity &gt; i) {\n        if (_bool_tokens_at_home) {\n          obj_matrix-&gt;drawPixel(u8_home_positions[i][j][0],\n                                u8_home_positions[i][j][1],\n                                u16_player_color[i][0]);\n        } else {\n          obj_matrix-&gt;drawPixel(u8_home_positions[i][j][0],\n                                u8_home_positions[i][j][1],\n                                u16_player_color[i][1]);\n        }\n      } else {\n        obj_matrix-&gt;drawPixel(u8_home_positions[i][j][0],\n                              u8_home_positions[i][j][1], 0x00);\n      }\n    }\n  }\n  // Finish Positions:\n  for (uint8_t i = 0; i &lt; 4; i++) {\n    for (uint8_t j = 0; j &lt; 4; j++) {\n      if (_u8_player_quantity &gt; i) {\n        obj_matrix-&gt;drawPixel(u8_finish_positions[i][j][0],\n                              u8_finish_positions[i][j][1],\n                              u16_player_color[i][1]);\n      } else {\n        obj_matrix-&gt;drawPixel(u8_finish_positions[i][j][0],\n                              u8_finish_positions[i][j][1], 0x00);\n      }\n    }\n  }\n}\n\nvoid ASL::cla_display::Display_Restore() {\n  obj_matrix-&gt;fillScreen(0x00);\n  Display_Track();\n}\n\nvoid ASL::cla_display::Display_Current_Player(int8_t _i8_current_player_number,\n                                              int8_t _i8_tokens_at_home) {\n  obj_matrix-&gt;drawLine(14, 2, 14, 12,\n                       u16_player_color[_i8_current_player_number][0]);\n  if (_i8_tokens_at_home != -1) {\n    Blink_Start(fast, 3, starting_square, _i8_current_player_number, -1,\n                _i8_tokens_at_home);\n  }\n}\n\nvoid ASL::cla_display::Display_Progress(int8_t _i8_current_player_number,\n                                        uint8_t _u8_progress) {\n  obj_matrix-&gt;drawLine(2, 14, 29, 14, 0x00);\n  obj_matrix-&gt;drawLine(2, 14, (1 + _u8_progress), 14,\n                       u16_player_color[_i8_current_player_number][0]);\n}\n\nvoid ASL::cla_display::Display_Char(char _ch_first_letter,\n                                    char _ch_second_letter,\n                                    char _ch_third_letter) {\n  // turn off the word pixels:\n  for (uint8_t i = 16; i &lt;= 31; i++) {\n    for (uint8_t j = 8; j &lt;= 12; j++) {\n      obj_matrix-&gt;drawPixel(i, j, 0x00);\n    }\n  }\n\n  obj_matrix-&gt;drawChar(15, 4, _ch_first_letter, u16_track_color, 0x00, 1);\n  obj_matrix-&gt;drawChar(20, 4, _ch_second_letter, u16_track_color, 0x00, 1);\n  obj_matrix-&gt;drawChar(25, 4, _ch_third_letter, u16_track_color, 0x00, 1);\n}\n\nvoid ASL::cla_display::Display_Clear_Right() {\n  for (uint8_t i = 16; i &lt;= 31; i++) {\n    for (uint8_t j = 0; j &lt;= 16; j++) {\n      obj_matrix-&gt;drawPixel(i, j, 0x00);\n    }\n  }\n}\n\nvoid ASL::cla_display::Blink_Start(\n    en_blink_mode _en_blink_mode, int8_t _i8_blink_cycles,\n    en_blink_type _en_blink_type, uint8_t _u8_blink_player_number,\n    int8_t _i8_blink_second_player, uint8_t _u8_new_position,\n    bool _bool_occupied_flag, uint8_t _u8_old_position) {\n  // write transfer parameters to class variables:\n  en_current_blink_mode = _en_blink_mode;\n  if (_i8_blink_cycles == -1) {\n    // if it is set to -1, we will blink forever.\n    i8_blink_counter = -1;\n  } else {\n    // multiply the blink cycles by 2, because the interupt routine will toggle\n    // AND subtract 1\n    i8_blink_counter = (_i8_blink_cycles &lt;&lt; 1);\n  }\n  en_current_blink_type = _en_blink_type;\n  u8_blink_player_number = _u8_blink_player_number;\n  u8_blink_old_position = _u8_old_position;\n  u8_blink_new_position = _u8_new_position;\n  u8_blink_state = 0;\n  if (_bool_occupied_flag) {\n    i8_blink_second_player = _i8_blink_second_player;\n  } else {\n    i8_blink_second_player = -1;\n  }\n\n  // Setup Timer 4 to CTC Mode with a prescaler of 256:\n  TCCR4A = 0;\n  TCCR4B = 0;\n  // WGM 42:40 = 010 -&gt; CTC Mode\n  TCCR4B |= (1 &lt;&lt; WGM42);\n  // CS 42:40 = 100 -&gt; Prescaler 256\n  TCCR4B |= (1 &lt;&lt; CS42);\n  // Set Output Compare:\n  if (en_current_blink_mode == fast) {\n    // Fast Blink\n    OCR4A = FAST_BLINK;\n  } else if (en_current_blink_mode == slow) {\n    // Slow Blink\n    OCR4A = SLOW_BLINK;\n  }\n  // Enable Interupt for Output Compare A:\n  TIMSK4 |= 1 &lt;&lt; OCIE4A;\n}\n\nbool ASL::cla_display::Blink_Update(bool _bool_isr_active) {\n  // Blinking is done in the interupt routine.\n  switch (en_current_blink_type) {\n  case token: // Token Blink\n    if (u8_blink_state == 0) {\n      Modify_Position(u8_blink_old_position, u8_blink_player_number, false);\n      Modify_Position(u8_blink_new_position, u8_blink_player_number, true);\n      u8_blink_state = 1;\n    } else {\n      Modify_Position(u8_blink_old_position, u8_blink_player_number, true);\n      if (i8_blink_second_player != -1) {\n        Modify_Position(u8_blink_new_position, i8_blink_second_player, true);\n      } else {\n        Modify_Position(u8_blink_new_position, u8_blink_player_number, false);\n      }\n      u8_blink_state = 0;\n    }\n    break;\n  case token_thrown: // Token Blink\n    if (u8_blink_state == 0) {\n      Modify_Position(u8_blink_new_position, u8_blink_player_number, true);\n      u8_blink_state = 1;\n    } else {\n      Modify_Position(u8_blink_new_position, i8_blink_second_player, true);\n      u8_blink_state = 0;\n    }\n    break;\n  case starting_square: // Starting Square Blink\n    if (u8_blink_state == 0) {\n      // Turn off all starting square positions of the player:\n      for (uint8_t i = 0; i &lt; 4; i++) {\n        obj_matrix-&gt;drawPixel(u8_home_positions[u8_blink_player_number][i][0],\n                              u8_home_positions[u8_blink_player_number][i][1],\n                              0x00);\n      }\n      u8_blink_state = 1;\n    } else {\n      uint8_t u8_tokens_at_home = u8_blink_new_position;\n      for (uint8_t i = 1; i &lt; 5; i++) {\n        if (u8_tokens_at_home &amp; 0x01) {\n          Modify_Position(i, u8_blink_player_number, true);\n        } else {\n          Modify_Position(i, u8_blink_player_number, false);\n        }\n        u8_tokens_at_home &gt;&gt;= 1;\n      }\n      u8_blink_state = 0;\n    }\n    break;\n  case winner_animation: // Winner Animation\n    // This animation is very cpu intensive, so we will only do it at the end of\n    // the loop funciton if the corresponding flag is set.\n    if (_bool_isr_active) {\n      return true;\n    }\n    if (u8_blink_state == 0) {\n      // Draw a Human beeing on the right side of the matrix:\n      for (uint8_t i = 0; i &lt; 26; i++) {\n        obj_matrix-&gt;drawPixel(u8_smiley_postitions[i][0] + 19,\n                              u8_smiley_postitions[i][1] + 4, 0x00);\n      }\n      for (uint8_t i = 0; i &lt; 26; i++) {\n        obj_matrix-&gt;drawPixel(u8_smiley_postitions[i][0] + 19,\n                              u8_smiley_postitions[i][1] + 3,\n                              u16_player_color[u8_blink_player_number][0]);\n      }\n      u8_blink_state = 1;\n    } else {\n      for (uint8_t i = 0; i &lt; 26; i++) {\n        obj_matrix-&gt;drawPixel(u8_smiley_postitions[i][0] + 19,\n                              u8_smiley_postitions[i][1] + 3, 0x00);\n      }\n      for (uint8_t i = 0; i &lt; 26; i++) {\n        obj_matrix-&gt;drawPixel(u8_smiley_postitions[i][0] + 19,\n                              u8_smiley_postitions[i][1] + 4,\n                              u16_player_color[u8_blink_player_number][0]);\n      }\n      u8_blink_state = 0;\n    }\n    break;\n  }\n  if (i8_blink_counter != -1) {\n    i8_blink_counter--;\n  }\n  if (i8_blink_counter == 0) {\n    Blink_Stop();\n  }\n  return false;\n}\n\nvoid ASL::cla_display::Blink_Stop() {\n  // make sure its actually blinking\n  if (en_current_blink_mode != off) {\n    // Disable Interupt for Output Compare A:\n    TIMSK4 &amp;= 0b11111110;\n    // Reset Timer 4:\n    TCCR4A = 0;\n    TCCR4B = 0;\n    OCR4A = 0;\n    // turn off Blink mode:\n    en_current_blink_mode = off;\n    switch (en_current_blink_type) {\n    case token:\n      // Partially Reset display:\n      Modify_Position(u8_blink_old_position, u8_blink_player_number, true);\n      if (i8_blink_second_player != -1) {\n        Modify_Position(u8_blink_new_position, i8_blink_second_player, true);\n      } else {\n        Modify_Position(u8_blink_new_position, u8_blink_player_number, false);\n      }\n      break;\n    case token_thrown:\n      // Partially Reset display:\n      Modify_Position(u8_blink_new_position, u8_blink_player_number, true);\n      break;\n    case starting_square: {\n      // Partially Reset display:\n      uint8_t u8_tokens_at_home = u8_blink_new_position;\n      for (uint8_t i = 1; i &lt; 5; i++) {\n        if (u8_tokens_at_home &amp; 0x01) {\n          Modify_Position(i, u8_blink_player_number, true);\n        } else {\n          Modify_Position(i, u8_blink_player_number, false);\n        }\n        u8_tokens_at_home &gt;&gt;= 1;\n      }\n      break;\n    }\n    case winner_animation: // Winner Animation\n      if (u8_blink_state == 0) {\n        // Draw a Human beeing on the right side of the matrix:\n        for (uint8_t i = 0; i &lt; 26; i++) {\n          obj_matrix-&gt;drawPixel(u8_smiley_postitions[i][0] + 19,\n                                u8_smiley_postitions[i][1] + 4, 0x00);\n        }\n      } else {\n        for (uint8_t i = 0; i &lt; 26; i++) {\n          obj_matrix-&gt;drawPixel(u8_smiley_postitions[i][0] + 19,\n                                u8_smiley_postitions[i][1] + 3, 0x00);\n        }\n      }\n      break;\n    }\n  }\n}\n\nbool ASL::cla_display::Blink_Is_On() {\n  if (en_current_blink_mode == off) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nvoid ASL::cla_display::Modify_Position(uint8_t _u8_position,\n                                       uint8_t _u8_player_number,\n                                       bool bool_turn_on) {\n  uint16_t u16_new_color = 0x00;\n  // Determine the new color of the pixel:\n  if (!bool_turn_on) {\n    if ((_u8_position &lt; 5) | (_u8_position &gt;= 45)) {\n      u16_new_color = u16_player_color[_u8_player_number][1];\n    } else {\n      u16_new_color = u16_track_color;\n    }\n  } else {\n    u16_new_color = u16_player_color[_u8_player_number][0];\n  }\n  // Draw the new pixel:\n  if (_u8_position &lt; 5) {\n    // Starting Square\n    _u8_position--;\n    obj_matrix-&gt;drawPixel(u8_home_positions[_u8_player_number][_u8_position][0],\n                          u8_home_positions[_u8_player_number][_u8_position][1],\n                          u16_new_color);\n  } else if ((_u8_position &gt;= 5) &amp;&amp; (_u8_position &lt; 45)) {\n    // Track\n    _u8_position -= 5;\n    obj_matrix-&gt;drawPixel(u8_track_positions[_u8_position][1],\n                          u8_track_positions[_u8_position][2], u16_new_color);\n  } else {\n    // Finish Square\n    _u8_position -= 45;\n    obj_matrix-&gt;drawPixel(\n        u8_finish_positions[_u8_player_number][_u8_position][0],\n        u8_finish_positions[_u8_player_number][_u8_position][1], u16_new_color);\n  }\n}\n\nvoid ASL::cla_display::Move_Token(uint8_t _u8_player_nr,\n                                  uint8_t _u8_old_position,\n                                  uint8_t _u8_new_position) {\n  Modify_Position(_u8_old_position, _u8_player_nr, false);\n  Modify_Position(_u8_new_position, _u8_player_nr, true);\n}\n\nvoid ASL::cla_display::Display_Dice(uint8_t _u8_dice_value,\n                                    uint8_t _u8_dice_roll_counter,\n                                    int8_t _i8_current_player_number,\n                                    bool _bool_animate) {\n  // Turn it all off:\n  obj_matrix-&gt;drawRect(16, 2, 5, 5, 0x00);\n  obj_matrix-&gt;drawPixel(18, 4, 0x00);\n  obj_matrix-&gt;drawPixel(17, 3, 0x00);\n  obj_matrix-&gt;drawPixel(17, 4, 0x00);\n  obj_matrix-&gt;drawPixel(17, 5, 0x00);\n  obj_matrix-&gt;drawPixel(19, 3, 0x00);\n  obj_matrix-&gt;drawPixel(19, 4, 0x00);\n  obj_matrix-&gt;drawPixel(19, 5, 0x00);\n  if (_bool_animate) {\n    // animate the rectangle drawing:\n    // set the rectangle values:\n    int x = 16; // top left corner\n    int y = 2;  // top left corner\n    int width = 5;\n    int height = 5;\n    // draw rectangle clockwise:\n    for (int i = 0; i &lt; width; i++) {\n      obj_matrix-&gt;drawPixel(x + i, y,\n                            u16_player_color[_i8_current_player_number][0]);\n      Delay_256(ANIMATION_SPEED_DICE);\n    }\n    for (int i = 1; i &lt; height; i++) {\n      obj_matrix-&gt;drawPixel(x + width - 1, y + i,\n                            u16_player_color[_i8_current_player_number][0]);\n      Delay_256(ANIMATION_SPEED_DICE);\n    }\n    for (int i = width - 2; i &gt;= 0; i--) {\n      obj_matrix-&gt;drawPixel(x + i, y + height - 1,\n                            u16_player_color[_i8_current_player_number][0]);\n      Delay_256(ANIMATION_SPEED_DICE);\n    }\n    for (int i = height - 2; i &gt; 0; i--) {\n      obj_matrix-&gt;drawPixel(x, y + i,\n                            u16_player_color[_i8_current_player_number][0]);\n      Delay_256(ANIMATION_SPEED_DICE);\n    }\n  } else {\n    obj_matrix-&gt;drawRect(16, 2, 5, 5,\n                         u16_player_color[_i8_current_player_number][0]);\n  }\n  switch (_u8_dice_roll_counter) {\n  case 0:\n    obj_matrix-&gt;drawPixel(17, 2, 0x00);\n    obj_matrix-&gt;drawPixel(18, 2, 0x00);\n    obj_matrix-&gt;drawPixel(19, 2, 0x00);\n    break;\n  case 1:\n    obj_matrix-&gt;drawPixel(17, 2,\n                          u16_player_color[_i8_current_player_number][0]);\n    obj_matrix-&gt;drawPixel(18, 2, 0x00);\n    obj_matrix-&gt;drawPixel(19, 2, 0x00);\n    break;\n  case 2:\n    obj_matrix-&gt;drawPixel(17, 2,\n                          u16_player_color[_i8_current_player_number][0]);\n    obj_matrix-&gt;drawPixel(18, 2,\n                          u16_player_color[_i8_current_player_number][0]);\n    obj_matrix-&gt;drawPixel(19, 2, 0x00);\n    break;\n  case 3:\n    obj_matrix-&gt;drawPixel(17, 2,\n                          u16_player_color[_i8_current_player_number][0]);\n    obj_matrix-&gt;drawPixel(18, 2,\n                          u16_player_color[_i8_current_player_number][0]);\n    obj_matrix-&gt;drawPixel(19, 2,\n                          u16_player_color[_i8_current_player_number][0]);\n    break;\n  }\n\n  switch (_u8_dice_value) {\n  case 0:\n    // Just leave it turned off.\n    break;\n  case 1:\n    obj_matrix-&gt;drawPixel(18, 4, u16_track_color);\n    break;\n  case 2:\n    obj_matrix-&gt;drawPixel(17, 3, u16_track_color);\n    obj_matrix-&gt;drawPixel(19, 5, u16_track_color);\n    break;\n  case 3:\n    obj_matrix-&gt;drawPixel(18, 4, u16_track_color);\n    obj_matrix-&gt;drawPixel(17, 3, u16_track_color);\n    obj_matrix-&gt;drawPixel(19, 5, u16_track_color);\n    break;\n  case 4:\n    obj_matrix-&gt;drawPixel(17, 3, u16_track_color);\n    obj_matrix-&gt;drawPixel(19, 5, u16_track_color);\n    obj_matrix-&gt;drawPixel(17, 5, u16_track_color);\n    obj_matrix-&gt;drawPixel(19, 3, u16_track_color);\n    break;\n  case 5:\n    obj_matrix-&gt;drawPixel(17, 3, u16_track_color);\n    obj_matrix-&gt;drawPixel(19, 5, u16_track_color);\n    obj_matrix-&gt;drawPixel(17, 5, u16_track_color);\n    obj_matrix-&gt;drawPixel(19, 3, u16_track_color);\n    obj_matrix-&gt;drawPixel(18, 4, u16_track_color);\n    break;\n  case 6:\n    obj_matrix-&gt;drawPixel(17, 3, u16_track_color);\n    obj_matrix-&gt;drawPixel(17, 4, u16_track_color);\n    obj_matrix-&gt;drawPixel(17, 5, u16_track_color);\n    obj_matrix-&gt;drawPixel(19, 3, u16_track_color);\n    obj_matrix-&gt;drawPixel(19, 4, u16_track_color);\n    obj_matrix-&gt;drawPixel(19, 5, u16_track_color);\n    break;\n  }\n}\n\nvoid ASL::Setup_Buttons() {\n  // Set PIN 2 and 3 to Input with external pull-up. PIN 2 and 3 correspond to\n  // DDE4 and DDE5.\n  // Set DDRE pin 4 and 5 to input\n  DDRE &amp;= 0b11001111;\n  // Set PORTE pin 4 and 5 to non-pull-up.\n  PORTE &amp;= 0b11001111;\n  PORTE |= 0b00110000;\n  //  We want the interupt to occur on falling edge, so ISCn1 = 1 and ISCn0 =\n  //  0 last 4 bits for INT5 and INT4.\n  EICRB &amp;= 0b11110000;\n  EICRB |= 0b00001010;\n  // Enable INT4 and INT5:\n  EIMSK |= 0b00110000;\n  // enable Global interupt\n  SREG |= 0b10000000;\n  // we will use a timer to disable interupts fo a short period of time after\n  // the first button press.\n  // set prescaler to 1024 -&gt; frequency is now 15.625kHz\n  // -&gt; T of 1 count cycle : 0,000064s\n  // -&gt; T of 0x1000 count cycles: 4096 * 0,000064s = 0,262144s\n  TCCR3A = 0;\n  TCCR3B = 0;\n  // Set Prescaler to 1024\n  TCCR3B |= (1 &lt;&lt; CS32) | (1 &lt;&lt; CS30);\n  // Set Output Compare to 0,262144s:\n  OCR3A = DEBOUNCE_TIME;\n  // Enable Interupt:\n  TIMSK3 |= 1 &lt;&lt; OCIE3A;\n}\n\nvoid ASL::Setup_Dice() {\n#if DICE_MODE == 0\n  // The Dice will use Counter 0 (8 Bit Counter).\n  // Set WGM1 to 1 and WGM0 to 0 (last 2 bits): CTC mode\n  TCCR0A = 1 &lt;&lt; WGM01;\n  // TCCR0A = 0b00000010;\n  // Set WGM2 to 0 (xxxx 0xxx)\n  // Set clock source to no prescaler (xxxx x001)\n  TCCR0B = 1 &lt;&lt; CS00;\n  // TCCR0B = 0b00000001;\n  // set reset value to 5 (6 values: 0:5 -&gt; need to add 1 later to get dice\n  // value 1:6)\n  OCR0A = 0x05;\n#elif DICE_MODE == 1\n  // Setup dice to read from Port L\n  // Set Port L to Input\n  DDRL = 0x00;\n  // Set Port L to Pull-Up\n  PORTL = 0xff;\n#elif DICE_MODE == 2\n  // No setup needed.\n#endif\n}\n\nuint8_t ASL::Roll_Dice() {\n  //\n#if DICE_MODE == 0\n  uint8_t i = TCNT0 + 1;\n#elif DICE_MODE == 1\n  uint8_t i = ~PINL;\n#elif DICE_MODE == 2\n  static uint8_t u8_dice_value_array_position;\n  uint8_t i = u8_dice_value_array[u8_dice_value_array_position];\n  if (u8_dice_value_array_position &lt; ((sizeof(u8_dice_value_array)) - 1)) {\n    u8_dice_value_array_position++;\n  } else {\n    u8_dice_value_array_position = 0;\n  }\n#endif\n  return i;\n}\n\nvoid ASL::Delay_256(uint16_t _u16_delay) {\n  // Set up Timer 5 to CTC Mode with a prescaler of 256:\n  TCCR5A = 0;\n  TCCR5B = 0;\n  TCNT5 = 0;\n  // WGM 52:50 = 010 -&gt; CTC Mode\n  TCCR5B |= (1 &lt;&lt; WGM52);\n  // CS 52:50 = 100 -&gt; Prescaler 256\n  TCCR5B |= (1 &lt;&lt; CS52);\n  // Set Output Compare:\n  OCR5A = _u16_delay;\n  // Enable Interupt for Output Compare A:\n  TIMSK5 |= 1 &lt;&lt; OCIE5A;\n  // Wait for the interupt to finish:\n  while (TIMSK5 &amp; (1 &lt;&lt; OCIE5A)) {\n  }\n  // Reset Timer 5:\n  TCCR5A = 0;\n  TCCR5B = 0;\n}\n</code></pre>"},{"location":"DeviceCode/ASL_8hpp/","title":"File ASL.hpp","text":"<p>FileList &gt; ASL &gt; ASL.hpp</p> <p>Go to the source code of this file</p> <p>This is the header file for the ASL library. More...</p> <ul> <li><code>#include &lt;../../include/defines.hpp&gt;</code></li> <li><code>#include &lt;RGBmatrixPanel.h&gt;</code></li> <li><code>#include &lt;inttypes.h&gt;</code></li> </ul>"},{"location":"DeviceCode/ASL_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace ASL"},{"location":"DeviceCode/ASL_8hpp/#classes","title":"Classes","text":"Type Name class cla_display display handler"},{"location":"DeviceCode/ASL_8hpp/#detailed-description","title":"Detailed Description","text":"<p>This file contains the forward declarations for:</p> <ul> <li>the cla_display class</li> <li>the ASL::Setup_Buttons() function</li> <li>the ASL::Setup_Dice() function</li> <li>the ASL::Roll_Dice() function</li> <li>the ASL::Delay_256() function</li> </ul> <p>The cla_display class is used to control the RGB LED Matrix. The Setup_Buttons() functions sets the interupt buttons. The Setup_Dice() function sets a timer ot run from 0 to 5 for the dice roll. The Roll_Dice() reads the value from the Timer that was set up in the Setup_Dice() function. The Delay_256() function is used to delay the program for a certain amount of time given by the transfer parameter. </p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/lib/ASL/ASL.hpp</code></p>"},{"location":"DeviceCode/ASL_8hpp_source/","title":"File ASL.hpp","text":"<p>File List &gt; ASL &gt; ASL.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ASL_HPP\n#define ASL_HPP\n\n#include &lt;../../include/defines.hpp&gt;\n#include &lt;RGBmatrixPanel.h&gt; // Hardware-specific library#\n#include &lt;inttypes.h&gt;\nnamespace ASL {\n\ntypedef enum {\n  display_setup_real_players = 0,\n  setup_real_players,                 // 1   0001\n  modify_real_player_number,          // 2   0010\n  display_setup_computer_players,     // 3   0011\n  setup_computer_players,             // 4   0100\n  modify_computer_player_number,      // 5   0101\n  display_setup_computer_player_mode, // 6   0110\n  setup_computer_player_mode,         // 7   0111\n  modify_computer_player_mode,        // 8   1000\n  init_game_logic,                    // 9   1001\n  wait_for_dice_roll,                 // 10  1010\n  roll_the_dice,                      // 11  1011\n  wait_for_player_input,              // 12  1100\n  display_token,                      // 13  1101\n  validate_token,                     // 14  1110\n  move_token,                         // 15  1111\n  next_player,                        // 16 10000\n  game_finished                       // 17 10001\n} en_state;\n\ntypedef enum { off = 0, fast, slow } en_blink_mode;\n\ntypedef enum {\n  token = 0,\n  token_thrown,\n  starting_square,\n  winner_animation\n} en_blink_type;\n\nclass cla_display {\n  uint8_t u8_matrix_a;   \n  uint8_t u8_matrix_b;   \n  uint8_t u8_matrix_c;   \n  uint8_t u8_matrix_clk; \n  uint8_t u8_matrix_lat; \n  uint8_t u8_matrix_oe;  \n#if TIMING_DEBUG_INTERN != 0\npublic:\n#endif\n  RGBmatrixPanel *obj_matrix;\n\n#if TIMING_DEBUG_INTERN != 0\nprivate:\n#endif\n\n  uint8_t u8_track_positions[40][3] = {\n      {5, 2, 6},   {6, 3, 6},   {7, 4, 6},   {8, 5, 6},   {9, 6, 6},\n      {10, 6, 5},  {11, 6, 4},  {12, 6, 3},  {13, 6, 2},  {14, 7, 2},\n      {15, 8, 2},  {16, 8, 3},  {17, 8, 4},  {18, 8, 5},  {19, 8, 6},\n      {20, 9, 6},  {21, 10, 6}, {22, 11, 6}, {23, 12, 6}, {24, 12, 7},\n      {25, 12, 8}, {26, 11, 8}, {27, 10, 8}, {28, 9, 8},  {29, 8, 8},\n      {30, 8, 9},  {31, 8, 10}, {32, 8, 11}, {33, 8, 12}, {34, 7, 12},\n      {35, 6, 12}, {36, 6, 11}, {37, 6, 10}, {38, 6, 9},  {39, 6, 8},\n      {40, 5, 8},  {41, 4, 8},  {42, 3, 8},  {43, 2, 8},  {44, 2, 7},\n  };\n\n  uint8_t u8_home_positions[4][4][2] = {\n      {{2, 2}, {2, 3}, {3, 2}, {3, 3}},\n      {{11, 2}, {11, 3}, {12, 2}, {12, 3}},\n      {{11, 11}, {11, 12}, {12, 11}, {12, 12}},\n      {{2, 11}, {2, 12}, {3, 11}, {3, 12}},\n  };\n\n  uint8_t u8_finish_positions[4][4][2] = {\n      {{3, 7}, {4, 7}, {5, 7}, {6, 7}},\n      {{7, 3}, {7, 4}, {7, 5}, {7, 6}},\n      {{11, 7}, {10, 7}, {9, 7}, {8, 7}},\n      {{7, 11}, {7, 10}, {7, 9}, {7, 8}},\n  };\n\n  uint8_t u8_smiley_postitions[26][2] = {\n      {0, 2}, {0, 3}, {0, 4}, {0, 5}, {1, 1}, {1, 6}, {2, 0}, {2, 2}, {2, 4},\n      {2, 7}, {3, 0}, {3, 5}, {3, 7}, {4, 0}, {4, 5}, {4, 7}, {5, 0}, {5, 2},\n      {5, 4}, {5, 7}, {6, 1}, {6, 6}, {7, 2}, {7, 3}, {7, 4}, {7, 5}};\n\n  uint16_t u16_player_color[4][2] = {\n      {0xf800, 0x1000},\n      {0x07e0, 0x00a0},\n      {0xffe0, 0x10a0},\n      {0x001f, 0x0002},\n  };\n\n  uint16_t u16_track_color = WHITE_BRIGHT;\n\n  // --- variables for the blink function ---\n  en_blink_mode en_current_blink_mode = off;\n  int8_t i8_blink_counter = 0;\n  en_blink_type en_current_blink_type = token;\n  uint8_t u8_blink_player_number = 0;\n  int8_t i8_blink_second_player = -1;\n  uint8_t u8_blink_old_position = 0;\n  uint8_t u8_blink_new_position = 0;\n  uint8_t u8_blink_state = 0;\n\npublic:\n  cla_display(uint8_t _u8_matrix_a, uint8_t u8_matrix_b, uint8_t u8_matrix_c,\n              uint8_t u8_matrix_clk, uint8_t u8_lat, uint8_t u8_matrix_oe);\n\n  void Set_Colors(uint8_t _u8_player_nr, uint16_t _u16_bright_color,\n                  uint16_t _u16_dark_color);\n\n  void Begin();\n\n  void Display_Track();\n\n  void Display_Players(uint8_t _u8_player_quantity,\n                       bool _bool_tokens_at_home = true);\n\n  void Display_Restore();\n\n  void Display_Current_Player(int8_t _i8_current_player_number,\n                              int8_t _i8_tokens_at_home = -1);\n\n  void Display_Progress(int8_t _i8_current_player_number, uint8_t _u8_progress);\n\n  void Display_Char(char _ch_first_letter = ' ', char _ch_second_letter = ' ',\n                    char _ch_third_letter = ' ');\n\n  void Display_Clear_Right();\n\n  void Blink_Start(en_blink_mode _en_blink_mode, int8_t _i8_blink_cycles,\n                   en_blink_type _en_blink_type,\n                   uint8_t _u8_blink_player_number,\n                   int8_t _i8_blink_second_player, uint8_t _u8_new_position = 0,\n                   bool _bool_occupied_flag = true,\n                   uint8_t _u8_old_position = 0);\n  bool Blink_Update(bool _bool_isr_active);\n\n  void Blink_Stop();\n\n  bool Blink_Is_On();\n\n  void Modify_Position(uint8_t _u8_position, uint8_t _u8_player_number,\n                       bool bool_remove);\n\n  void Move_Token(uint8_t _u8_player_nr, uint8_t _u8_remove_position,\n                  uint8_t _u8_add_position);\n\n  void Display_Dice(uint8_t _u8_dice_value, uint8_t _u8_dice_roll_counter,\n                    int8_t _i8_current_player_number,\n                    bool _bool_animate = true);\n};\n\nvoid Setup_Buttons();\n\nvoid Setup_Dice();\n\nuint8_t Roll_Dice();\n\nvoid Delay_256(uint16_t _u16_delay);\n\n} // namespace ASL\n\n#endif\n</code></pre>"},{"location":"DeviceCode/dir_a4eb90df38054bf38c8301b489299593/","title":"Dir Game_Logic","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; lib &gt; Game_Logic</p>"},{"location":"DeviceCode/dir_a4eb90df38054bf38c8301b489299593/#files","title":"Files","text":"Type Name file logic.cpp This file contains the implementation of the game logic. file logic.hpp This file is the header file for the game logic library. <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/lib/Game_Logic/</code></p>"},{"location":"DeviceCode/logic_8cpp/","title":"File logic.cpp","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; lib &gt; Game_Logic &gt; logic.cpp</p> <p>Go to the source code of this file</p> <p>This file contains the implementation of the game logic. More...</p> <ul> <li><code>#include \"logic.hpp\"</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> </ul>"},{"location":"DeviceCode/logic_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace LOGIC"},{"location":"DeviceCode/logic_8cpp/#detailed-description","title":"Detailed Description","text":"<p>This file implements: * The cla_session class * The cla_player class * The cla_computer_player class * The cla_manual_player class </p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/lib/Game_Logic/logic.cpp</code></p>"},{"location":"DeviceCode/logic_8cpp_source/","title":"File logic.cpp","text":"<p>File List &gt; COD_ENG_OUT_arduino_code &gt; lib &gt; Game_Logic &gt; logic.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"logic.hpp\"\n#ifndef __AVR__\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#else\n#include &lt;Arduino.h&gt;\n#endif\n\nnamespace LOGIC {\ncla_session::cla_session(uint8_t _u8_player_quantity,\n                         uint8_t _u8_computer_quantity, mode _en_mode) {\n  u8_player_quantity = _u8_player_quantity;\n  u8_computer_quantity = _u8_computer_quantity;\n  array_players[u8_player_quantity];\n  u8_is_occupied_player_id = 10;\n  u8_is_occupied_token_number = 10;\n\n  for (int i = 0; i &lt; _u8_player_quantity; i++) {\n    if (_u8_player_quantity - _u8_computer_quantity &gt; i)\n      array_players[i] =\n          new cla_manual_player(i, 5 + i * 10, _u8_computer_quantity,\n                                this); // ID = i, Startposition = 5 + i * 10\n    else {\n      array_players[i] = new cla_computer_player(\n          i, 5 + i * 10, _u8_computer_quantity, this,\n          _en_mode); // ID = i, Startposition = 5 + i * 10\n    }\n  }\n};\n\ncla_player::cla_player(uint8_t _u8_player_id, uint8_t _u8_start_position,\n                       uint8_t _u8_computer_quantity,\n                       cla_session *_obj_my_session) {\n  obj_my_session = _obj_my_session;\n  u8_player_id = _u8_player_id;\n  u8_start_position = _u8_start_position;\n  for (int p = 0; p &lt; 4; p++) {\n    u8_token_position[p] =\n        p + 1; // So each token has a unique position in the home field\n  }\n};\n\ncla_computer_player::cla_computer_player(uint8_t _u8_player_id,\n                                         uint8_t _u8_start_position,\n                                         uint8_t _u8_computer_quantity,\n                                         cla_session *_obj_my_session,\n                                         mode _en_mode)\n    : cla_player(_u8_player_id, _u8_start_position, _u8_computer_quantity,\n                 _obj_my_session) {\n  this-&gt;en_mode = _en_mode;\n}\n\ncla_manual_player::cla_manual_player(uint8_t _u8_player_id,\n                                     uint8_t _u8_start_position,\n                                     uint8_t _u8_computer_quantity,\n                                     cla_session *_obj_my_session)\n    : cla_player(_u8_player_id, _u8_start_position, _u8_computer_quantity,\n                 _obj_my_session) {}\n\nbool cla_session::Is_Occupied(uint8_t &amp;_u8_is_occupied_player_id,\n                              uint8_t &amp;_u8_is_occupied_token_number,\n                              uint8_t _u8_affected_track_position) {\n  if (_u8_affected_track_position &gt; 44) {\n    _u8_is_occupied_player_id = 10;\n    u8_is_occupied_token_number = 10;\n    return false;\n  } // In finish no token of a other player can be thrown\n  for (uint8_t i = 0; i &lt; u8_player_quantity; i++) {\n    for (uint8_t a = 0; a &lt; 4; a++) {\n      if (array_players[i]-&gt;Get_Token_Position(a) ==\n          _u8_affected_track_position) {\n        _u8_is_occupied_player_id = i;\n        _u8_is_occupied_token_number = a;\n        return true; // i stands for the player ID, a for the token number\n      }\n    }\n  }\n  _u8_is_occupied_player_id = 10;\n  u8_is_occupied_token_number = 10;\n  return false; // 10 stands for no player/token at the given track position\n}\n\nbool cla_session::Return_Home(uint8_t _u8_affected_track_position) {\n  if (Is_Occupied(u8_is_occupied_player_id, u8_is_occupied_token_number,\n                  _u8_affected_track_position)) {\n    array_players[u8_is_occupied_player_id]-&gt;Set_Token_Position(\n        u8_is_occupied_token_number,\n        u8_is_occupied_token_number +\n            1); // Set_Token_Position sets the token\n                // position to the home field (1,2,3,4)\n    return true;\n  } else {\n    return false;\n  }\n};\n\nuint8_t cla_player::Calculate_Possible_Position(uint8_t _u8_token_number,\n                                                uint8_t _u8_dice_value) {\n  uint8_t u8_token_progress = Get_Token_Progress(_u8_token_number);\n  uint8_t u8_possible_absolute_position = 0;\n\n  if ((u8_token_position[_u8_token_number] &lt;= 4) &amp;&amp;\n      (_u8_dice_value ==\n       6)) { // token is in the home field and would move onto the track\n    if (obj_my_session-&gt;Is_Occupied(obj_my_session-&gt;u8_is_occupied_player_id,\n                                    obj_my_session-&gt;u8_is_occupied_token_number,\n                                    u8_start_position) == true &amp;&amp;\n        obj_my_session-&gt;u8_is_occupied_player_id == u8_player_id) {\n      u8_possible_absolute_position =\n          u8_token_position[_u8_token_number]; // token would throw itself\n                                               // -&gt; invalide move\n    } else {\n      u8_possible_absolute_position = u8_start_position;\n    }\n  } else if (u8_token_position[_u8_token_number] &lt;= 4 &amp;&amp;\n             _u8_dice_value != 6) { // token is in the home field and would\n                                    // not move onto the track\n    u8_possible_absolute_position = u8_token_position[_u8_token_number];\n  } else if (u8_token_progress + _u8_dice_value &gt; 39 &amp;&amp;\n             u8_token_progress + _u8_dice_value &lt;\n                 44) { // token is on the track and would move into\n                       // the finish and finish is not blocked by own\n                       // token\n    u8_possible_absolute_position = u8_token_progress + _u8_dice_value + 5;\n  } else if (u8_token_progress + _u8_dice_value &gt;\n             43) { // token is on the track and would move out of the\n                   // finish\n    u8_possible_absolute_position = u8_token_position[_u8_token_number];\n  } else if (u8_token_position[_u8_token_number] &gt; 44 &amp;&amp;\n             u8_token_position[_u8_token_number] + _u8_dice_value &lt; 49) {\n    // token is in the finish and would not move out of the finish and finish is\n    // not blocked by own token\n    u8_possible_absolute_position =\n        u8_token_position[_u8_token_number] + _u8_dice_value;\n  } else if (u8_token_position[_u8_token_number] &gt; 44 &amp;&amp;\n             u8_token_position[_u8_token_number] + _u8_dice_value &gt; 49) {\n    // token is in the finish and would move out of the finish\n    u8_possible_absolute_position = u8_token_position[_u8_token_number];\n  } else {\n    uint8_t u8_possible_position =\n        u8_token_position[_u8_token_number] + _u8_dice_value;\n    if (u8_possible_position &gt;\n        44) { // token is on track and would move out of the track\n      u8_possible_position = u8_possible_position - 40;\n    }\n    u8_possible_absolute_position = u8_possible_position;\n  }\n  for (int i = 0; i &lt; 4; i++) {\n    if (u8_possible_absolute_position == u8_token_position[i]) {\n      return u8_token_position[_u8_token_number];\n    }\n  } // token would throw itself -&gt; invalide move\n  return u8_possible_absolute_position;\n};\n\nuint8_t cla_player::Move_Token(uint8_t _u8_token_number,\n                               uint8_t _u8_dice_value) {\n  uint8_t u8_possible_position =\n      Calculate_Possible_Position(_u8_token_number, _u8_dice_value);\n  bool bool_is_occupied = obj_my_session-&gt;Is_Occupied(\n      obj_my_session-&gt;u8_is_occupied_player_id,\n      obj_my_session-&gt;u8_is_occupied_token_number, u8_possible_position);\n  if (u8_possible_position ==\n      Get_Token_Position(\n          _u8_token_number)) { // token stays on the same position (e.g would\n                               // move out of the finish)\n    return Get_Token_Position(_u8_token_number);\n  } else if (bool_is_occupied == false) {\n    // possible position is not occupied\n    u8_token_position[_u8_token_number] = u8_possible_position;\n    return u8_possible_position;\n  } else if (bool_is_occupied == true &amp;&amp;\n             obj_my_session-&gt;u8_is_occupied_player_id != u8_player_id &amp;&amp;\n             u8_possible_position &lt;= 44) {\n    // possible position is occupied by another player -&gt; other player gets\n    // sent home\n    obj_my_session-&gt;Return_Home(u8_possible_position);\n    u8_token_position[_u8_token_number] = u8_possible_position;\n    return u8_possible_position;\n  } else {\n    return 0; // Error\n  }\n};\n\nint8_t cla_player::Is_Start_Field_Occupied_By_Own_Token() {\n  uint8_t u8_counter = 0;\n  for (uint8_t token = 0; token &lt; 4; token++) {\n    if (Get_Token_Position(token) &lt;= 4) {\n      u8_counter = u8_counter + 1;\n    } else {\n      u8_counter = u8_counter;\n    }\n  };\n  if (obj_my_session-&gt;Is_Occupied(obj_my_session-&gt;u8_is_occupied_player_id,\n                                  obj_my_session-&gt;u8_is_occupied_token_number,\n                                  u8_start_position) &amp;&amp;\n      u8_player_id == obj_my_session-&gt;u8_is_occupied_player_id &amp;&amp;\n      u8_counter &gt; 0) {\n    return obj_my_session-&gt;u8_is_occupied_token_number;\n  } else {\n    return -1; // no own token at the start position\n  }\n};\n\nuint8_t cla_player::Get_Token_Position(uint8_t _u8_token_number) {\n  return u8_token_position[_u8_token_number];\n};\n\nuint8_t cla_player::Set_Token_Position(uint8_t _u8_token_number,\n                                       uint8_t _u8_new_position) {\n  u8_token_position[_u8_token_number] = _u8_new_position;\n  return u8_token_position[_u8_token_number];\n};\n\nuint8_t cla_player::Get_Token_Progress(uint8_t _u8_token_number) {\n  if (u8_token_position[_u8_token_number] &gt;= 5) { // token is on the track\n    int8_t i8_token_progress =\n        u8_token_position[_u8_token_number] - u8_start_position;\n    if (i8_token_progress &lt; 0) { // to compensate the offset for each player\n      i8_token_progress =\n          u8_token_position[_u8_token_number] + 40 - u8_start_position;\n    }\n    if (u8_token_position[_u8_token_number] &gt; 44) {\n      i8_token_progress = u8_token_position[_u8_token_number] -\n                          5; // to compensate the offset on the field\n    }\n    return i8_token_progress; // cannot be negative\n  } else {\n    return 0;\n  }\n};\n\nstatus cla_player::Get_Player_Status() {\n  uint8_t u8_status = 0; // Position &lt; 5 -&gt; start, 5&lt;=Position&lt;=44 -&gt; Track,\n                         // Position &gt; 44 -&gt; Finished\n  for (int i = 0; i &lt; 4; i++) {\n    if (u8_token_position[i] &lt;= 4) {\n      u8_status += 0;\n    } else if (u8_token_position[i] &lt;= 44) {\n      u8_status += 1;\n    } else if (u8_token_position[i] &gt; 44) {\n      u8_status += 10;\n    }\n  };\n  if (u8_status == 0) {\n    return Start; // all tokens are in start\n  } else if (u8_status &gt; 0 &amp;&amp;\n             u8_status &lt;\n                 4) { // at least one token is on the track, rest is in start\n    return Start_Track;\n  } else if (u8_status == 10 or u8_status == 20 or\n             u8_status == 30) { // max 3 token are finished, rest in start\n    return Start_Finished;\n  } else if (u8_status &gt; 10 &amp;&amp; u8_status &lt;= 12 or\n             u8_status &gt; 20 &amp;&amp;\n                 u8_status &lt;= 21) { // at least one is in start, one is\n                                    // finished, rest on track\n    return Start_Track_Finished;\n  } else if (u8_status == 4) { // all tokens are on the track\n    return Track;\n  } else if (u8_status == 40) { // all tokens are finished\n    return Finished;\n  } else if (u8_status == 13 or u8_status == 22 or\n             u8_status ==\n                 31) { // at least one token is on track, rest is finished\n    return Track_Finished;\n  } else {\n    return Error;\n  }\n};\n\nuint8_t cla_player::Get_Player_Progress() {\n  uint8_t u8_overall_progress = 0;\n  for (uint8_t u8_token_number = 0; u8_token_number &lt; 4; u8_token_number++) {\n    u8_overall_progress +=\n        this-&gt;cla_player::Get_Token_Progress(u8_token_number);\n  }\n  if (u8_overall_progress == 166) {\n    return 28; // 166 means all tokens are in the finish\n  }\n  float f_scaled_progress =\n      ((float)u8_overall_progress / 166.0f) * 27.0f + 1.0f;\n  // To display the progress on LED-Matrix it nedds to be scaled to 1-28\n  uint8_t u8_scaled_progress_rounded = (uint8_t)(f_scaled_progress + 0.5f);\n\n  if (u8_scaled_progress_rounded &gt; 27) {\n    u8_scaled_progress_rounded = 27;\n  } // 28 is the maximum progress and is only allowed to be reached when all\n    // tokens are in the finish (166)\n\n  return u8_scaled_progress_rounded;\n};\n\nint8_t cla_computer_player::Auto_Move(uint8_t _u8_dice_value,\n                                      bool &amp;_bool_occupied_flag,\n                                      uint8_t &amp;_u8_old_position) {\n  int8_t i8_start_field_occupied_by_own_token =\n      Is_Start_Field_Occupied_By_Own_Token();\n  if (i8_start_field_occupied_by_own_token != -1) {\n    _u8_old_position = Get_Token_Position(i8_start_field_occupied_by_own_token);\n    _bool_occupied_flag = obj_my_session-&gt;Is_Occupied(\n        obj_my_session-&gt;u8_is_occupied_player_id,\n        obj_my_session-&gt;u8_is_occupied_token_number,\n        Calculate_Possible_Position(i8_start_field_occupied_by_own_token,\n                                    _u8_dice_value));\n    Move_Token(i8_start_field_occupied_by_own_token, _u8_dice_value);\n    // Computer must move away from start field if other tokens are in start\n    return i8_start_field_occupied_by_own_token;\n  } else if (_u8_dice_value == 6) {\n    bool bool_home_occupied = false;\n    for (int i = 0; i &lt; 4; i++) {\n      if (Get_Token_Position(i) &lt;= 4) {\n        bool_home_occupied = true;\n      }\n      if (bool_home_occupied) {\n        _u8_old_position = Get_Token_Position(i);\n        _bool_occupied_flag = obj_my_session-&gt;Is_Occupied(\n            obj_my_session-&gt;u8_is_occupied_player_id,\n            obj_my_session-&gt;u8_is_occupied_token_number, u8_start_position);\n        Move_Token(i, _u8_dice_value);\n        return i;\n        // Computer must move a token out of the home field if at least one\n        // token is in the home field\n      }\n    }\n  }\n  bool token_moved = false;\n  switch (en_mode) {\n  case Student:\n    for (int n = 0; n &lt; 4; n++) {\n      uint8_t u8_possible_position =\n          Calculate_Possible_Position(n, _u8_dice_value);\n      // Check if a token can be moved (from token 0 to 3)\n      if (u8_possible_position &gt; 4 &amp;&amp;\n          u8_possible_position != Get_Token_Position(n)) {\n        // set occupied flag\n        _bool_occupied_flag = obj_my_session-&gt;Is_Occupied(\n            obj_my_session-&gt;u8_is_occupied_player_id,\n            obj_my_session-&gt;u8_is_occupied_token_number, u8_possible_position);\n        // set old position flag\n        _u8_old_position = Get_Token_Position(n);\n        Move_Token(n, _u8_dice_value);\n        return n; // Token number that was moved\n      }\n    }\n    return -1; // No token could be moved\n\n  case Professor:\n    for (int n = 0; n &lt; 4; n++) {\n      uint8_t u8_possible_position =\n          Calculate_Possible_Position(n, _u8_dice_value);\n      if (obj_my_session-&gt;Is_Occupied(\n              obj_my_session-&gt;u8_is_occupied_player_id,\n              obj_my_session-&gt;u8_is_occupied_token_number,\n              u8_possible_position) == true &amp;&amp;\n          obj_my_session-&gt;u8_is_occupied_player_id != u8_player_id &amp;&amp;\n          u8_possible_position &lt;= 44 &amp;&amp; u8_possible_position &gt; 4) {\n        _u8_old_position = Get_Token_Position(n);\n        Move_Token(n, _u8_dice_value);\n        token_moved = true;\n        _bool_occupied_flag = true;\n        return n;\n      }\n    }\n    // If no token could be moved -&gt; student move (Fallback-Solution)\n    if (token_moved == false) {\n      for (int m = 0; m &lt; 4; m++) {\n        uint8_t u8_possible_position =\n            Calculate_Possible_Position(m, _u8_dice_value);\n        // Check if a token can be moved (from token 0 to 3)\n        if (u8_possible_position &gt; 4 &amp;&amp;\n            u8_possible_position != Get_Token_Position(m)) {\n          // set occupied flag\n          _bool_occupied_flag = obj_my_session-&gt;Is_Occupied(\n              obj_my_session-&gt;u8_is_occupied_player_id,\n              obj_my_session-&gt;u8_is_occupied_token_number,\n              u8_possible_position);\n          // set old position flag\n          _u8_old_position = Get_Token_Position(m);\n          Move_Token(m, _u8_dice_value);\n          return m;\n        }\n      }\n    }\n    return -1; // No token could be moved\n\n  default:\n    return -1; // Error\n  }\n}\n\nuint8_t cla_session::Get_Player_Quantity() { return u8_player_quantity; };\n\nuint8_t cla_session::Get_Computer_Quantity() { return u8_computer_quantity; };\n\nuint8_t cla_player::Get_Start_Position() { return u8_start_position; };\n\nint8_t cla_player::Auto_Move(uint8_t _u8_dice_value, bool &amp;_bool_occupied_flag,\n                             uint8_t &amp;_u8_old_position) {\n  return -1;\n};\n\n} // namespace LOGIC\n</code></pre>"},{"location":"DeviceCode/logic_8hpp/","title":"File logic.hpp","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; lib &gt; Game_Logic &gt; logic.hpp</p> <p>Go to the source code of this file</p> <p>This file is the header file for the game logic library. More...</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"DeviceCode/logic_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace LOGIC"},{"location":"DeviceCode/logic_8hpp/#classes","title":"Classes","text":"Type Name class cla_computer_player This class represents a computer opponent in the game. It provides methods for automatic movement of tokens. It is derived from the cla_player . class cla_manual_player This class represents a manual player in a game. It is derived from the cla_player class. class cla_player This class represents a player in the game. It provides methods for moving tokens and checking the status of the player. It is an abstract class and has two derived classes: cla_computer_player andcla_manual_player . class cla_session The cla_session class is the main class of the game logic. It initializes the players with their methods and it provides essential methods for the game logic."},{"location":"DeviceCode/logic_8hpp/#detailed-description","title":"Detailed Description","text":"<p>This file contains the declaration of the classes cla_session, cla_player, cla_computer_player and cla_manual_player. The cla_session class is the main class of the game logic. It initializes the players with their methods and it provides essential methods for the game logic. The cla_player class represents a player in the game. It provides methods for moving tokens and checking the status of the player. It is an abstract class and has two derived classes: * cla_computer_player * cla_manual_player. The cla_computer_player class represents a computer opponent in the game. It provides methods for automatic movement of tokens. The cla_manual_player class represents a manual player in a game. </p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/lib/Game_Logic/logic.hpp</code></p>"},{"location":"DeviceCode/logic_8hpp_source/","title":"File logic.hpp","text":"<p>File List &gt; COD_ENG_OUT_arduino_code &gt; lib &gt; Game_Logic &gt; logic.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef LOGIC_HPP\n#define LOGIC_HPP\n\n#ifndef __AVR__ // For arduino\n#include &lt;cstdint&gt;\n#else\n#include &lt;Arduino.h&gt;\n#endif\n\nnamespace LOGIC {\n\n// Forward declaration of cla_player\nclass cla_player;\n\ntypedef enum {\n  Start = 0,\n  Start_Track,\n  Start_Finished,\n  Start_Track_Finished,\n  Error,\n  Track,\n  Finished,\n  Track_Finished,\n} status;\n\ntypedef enum {\n  Student = 0,\n  Professor = 1,\n} mode;\n\nclass cla_session {\npublic:\n  cla_session(uint8_t _u8_player_quantity, uint8_t _u8_computer_quantity,\n              mode _en_mode);\n\n  cla_player *array_players[4]; \n\n  bool Is_Occupied(uint8_t &amp;_u8_is_occupied_player_id,\n                   uint8_t &amp;_u8_is_occupied_token_number,\n                   uint8_t _u8_affected_track_position);\n\n  bool Return_Home(uint8_t _u8_affected_track_position);\n\n  uint8_t Get_Player_Quantity(); \n\n  uint8_t Get_Computer_Quantity(); \n\n  uint8_t u8_is_occupied_player_id;    \n  uint8_t u8_is_occupied_token_number; \nprivate:\n  uint8_t u8_player_quantity;   \n  uint8_t u8_computer_quantity; \n};\n\nclass cla_player {\npublic:\n  cla_player(uint8_t _u8_player_id, uint8_t _u8_start_position,\n             uint8_t _u8_computer_quantity, cla_session *_obj_my_session);\n\n  uint8_t Calculate_Possible_Position(uint8_t _u8_token_number,\n                                      uint8_t _u8_dice_value);\n\n  uint8_t Move_Token(uint8_t _u8_token_number, uint8_t _u8_dice_value);\n\n  int8_t Is_Start_Field_Occupied_By_Own_Token();\n\n  uint8_t Get_Token_Position(uint8_t _u8_token_number);\n\n  uint8_t Set_Token_Position(uint8_t _u8_token_number,\n                             uint8_t _u8_new_position);\n\n  uint8_t Get_Token_Progress(uint8_t _u8_token_number);\n\n  status Get_Player_Status();\n\n  uint8_t Get_Player_Progress();\n\n  virtual bool Is_Computer() const = 0;\n\n  uint8_t\n  Get_Start_Position(); \n\n  virtual int8_t Auto_Move(uint8_t _u8_dice_value, bool &amp;_bool_occupied_flag,\n                           uint8_t &amp;_u8_old_position);\n\nprotected:\n  uint8_t u8_start_position;    \n  uint8_t u8_token_position[4]; \n  uint8_t u8_player_id;         \n  cla_session *obj_my_session;  \n};\n\nclass cla_computer_player : public cla_player {\npublic:\n  cla_computer_player(uint8_t _u8_player_id, uint8_t _u8_start_position,\n                      uint8_t _u8_computer_quantity,\n                      cla_session *_obj_my_session, mode _en_mode);\n\n  int8_t Auto_Move(uint8_t _u8_dice_value, bool &amp;_bool_occupied_flag,\n                   uint8_t &amp;_u8_old_position) override;\n\n  virtual bool Is_Computer() const override { return true; }\n\nprotected:\n  mode en_mode; \n};\n\nclass cla_manual_player : public cla_player {\npublic:\n  cla_manual_player(uint8_t _u8_player_id, uint8_t _u8_start_position,\n                    uint8_t _u8_computer_quantity,\n                    cla_session *_obj_my_session);\n  virtual bool Is_Computer() const override { return false; }\n};\n\n} // namespace LOGIC\n\n#endif // LOGIC_HPP\n</code></pre>"},{"location":"DeviceCode/dir_38410eb1dec6281e0e0807d9e6ad57cf/","title":"Dir src","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; src</p>"},{"location":"DeviceCode/dir_38410eb1dec6281e0e0807d9e6ad57cf/#files","title":"Files","text":"Type Name file animations.cpp This file contains the animations for the game. file interupt.cpp This file contains all interupt routines. file main.cpp This file contains the main loop and setup of the game. <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/src/</code></p>"},{"location":"DeviceCode/animations_8cpp/","title":"File animations.cpp","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; src &gt; animations.cpp</p> <p>Go to the source code of this file</p> <p>This file contains the animations for the game. More...</p> <ul> <li><code>#include &lt;ASL.hpp&gt;</code></li> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;defines.hpp&gt;</code></li> <li><code>#include &lt;logic.hpp&gt;</code></li> </ul>"},{"location":"DeviceCode/animations_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Move_Token (int8_t _i8_current_player_number, uint8_t _u8_remove_position, uint8_t _u8_add_position, ASL::cla_display * _obj_display, LOGIC::cla_session * _obj_session, uint8_t _u8_player_quantity, uint8_t _u8_dice_value) This function animates the token movement."},{"location":"DeviceCode/animations_8cpp/#macros","title":"Macros","text":"Type Name define ANIMATIONS"},{"location":"DeviceCode/animations_8cpp/#detailed-description","title":"Detailed Description","text":"<p>In this file, all functions that display animations are defined. </p>"},{"location":"DeviceCode/animations_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"DeviceCode/animations_8cpp/#function-move_token","title":"function Move_Token","text":"<p>This function animates the token movement. <pre><code>void Move_Token (\n    int8_t _i8_current_player_number,\n    uint8_t _u8_remove_position,\n    uint8_t _u8_add_position,\n    ASL::cla_display * _obj_display,\n    LOGIC::cla_session * _obj_session,\n    uint8_t _u8_player_quantity,\n    uint8_t _u8_dice_value\n) \n</code></pre></p> <p>This function animates the movement of a token from one position to another.</p> <p>Parameters:</p> <ul> <li><code>_i8_current_player_number</code> The number of the current player. </li> <li><code>_u8_remove_position</code> The start position for the token to start walking. </li> <li><code>_u8_add_position</code> The end position for the token to stop walking. </li> <li><code>_obj_display</code> Pointer to the display object. </li> <li><code>_obj_session</code> Pointer to the session object. </li> <li><code>_u8_player_quantity</code> The number of players. </li> <li><code>_u8_dice_value</code> The distance the token will walk. </li> </ul>"},{"location":"DeviceCode/animations_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"DeviceCode/animations_8cpp/#define-animations","title":"define ANIMATIONS","text":"<pre><code>#define ANIMATIONS \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/src/animations.cpp</code></p>"},{"location":"DeviceCode/animations_8cpp_source/","title":"File animations.cpp","text":"<p>File List &gt; COD_ENG_OUT_arduino_code &gt; src &gt; animations.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ANIMATIONS\n#define ANIMATIONS\n#include &lt;ASL.hpp&gt;\n#include &lt;Arduino.h&gt;\n#include &lt;defines.hpp&gt;\n#include &lt;logic.hpp&gt;\n\nvoid Move_Token(int8_t _i8_current_player_number, uint8_t _u8_remove_position,\n                uint8_t _u8_add_position, ASL::cla_display *_obj_display,\n                LOGIC::cla_session *_obj_session, uint8_t _u8_player_quantity,\n                uint8_t _u8_dice_value) {\n  bool bool_jump = false;\n  uint8_t i = _u8_remove_position;\n  if (_u8_remove_position != _u8_add_position) {\n    // only move if the position is not the same\n    do {\n      i++;\n      // take care of the old position\n      if (bool_jump) {\n        bool_jump = false;\n      } else {\n        uint8_t u8_modify_position = i - 1;\n        if (i == 5) {\n          u8_modify_position = 44;\n        }\n        _obj_display-&gt;Modify_Position((u8_modify_position),\n                                      _i8_current_player_number, false);\n      }\n      // handle case that the end of the track is reached\n      if (((i) == 45) &amp;&amp; (_i8_current_player_number != 0)) {\n        i = 5;\n      }\n      // handle case of end position\n      switch (_i8_current_player_number) {\n      case 0:\n        if (i == 45) {\n          i = 45;\n        }\n        break;\n      case 1:\n        if (i == 15) {\n          i = 45;\n        }\n        break;\n      case 2:\n        if (i == 25) {\n          i = 45;\n        }\n        break;\n      case 3:\n        if (i == 35) {\n          i = 45;\n        }\n        break;\n      }\n      // check if the current position is occupied, only if its not the end\n      // position\n      if (i != _u8_add_position) {\n        for (uint8_t u8_player_i = 0; u8_player_i &lt; _u8_player_quantity;\n             u8_player_i++) {\n          for (uint8_t u8_token_i = 0; u8_token_i &lt; 4; u8_token_i++) {\n            if (_obj_session-&gt;array_players[u8_player_i]-&gt;Get_Token_Position(\n                    u8_token_i) == (i)) {\n              // skip that position\n              bool_jump = true;\n            }\n          }\n        }\n      }\n      // Set the new position\n      if (!bool_jump) {\n        _obj_display-&gt;Modify_Position(i, _i8_current_player_number, true);\n        ASL::Delay_256(ANIMATION_SPEED_MOVE);\n      }\n    } while (i != _u8_add_position);\n  }\n}\n\n#endif\n</code></pre>"},{"location":"DeviceCode/interupt_8cpp/","title":"File interupt.cpp","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; src &gt; interupt.cpp</p> <p>Go to the source code of this file</p> <p>This file contains all interupt routines. </p> <ul> <li><code>#include &lt;ASL.hpp&gt;</code></li> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;logic.hpp&gt;</code></li> </ul>"},{"location":"DeviceCode/interupt_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name bool bool_blink_flag ASL::en_state en_current_state int8_t i8_current_token_number ASL::cla_display obj_display uint8_t u8_computer_quantity uint8_t u8_player_quantity"},{"location":"DeviceCode/interupt_8cpp/#public-functions","title":"Public Functions","text":"Type Name ISR (INT4_vect) interupt routine for the Choose (green) Button. ISR (INT5_vect) interupt routine for the Submit (red) Button. ISR (TIMER3_COMPA_vect) interupt routine for the Timer 3. ISR (TIMER4_COMPA_vect) interupt routine for the Timer 4. ISR (TIMER5_COMPA_vect) interupt routine for the Timer 5."},{"location":"DeviceCode/interupt_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"DeviceCode/interupt_8cpp/#variable-bool_blink_flag","title":"variable bool_blink_flag","text":"<pre><code>volatile bool bool_blink_flag;\n</code></pre>"},{"location":"DeviceCode/interupt_8cpp/#variable-en_current_state","title":"variable en_current_state","text":"<pre><code>volatile ASL::en_state en_current_state;\n</code></pre>"},{"location":"DeviceCode/interupt_8cpp/#variable-i8_current_token_number","title":"variable i8_current_token_number","text":"<pre><code>volatile int8_t i8_current_token_number;\n</code></pre>"},{"location":"DeviceCode/interupt_8cpp/#variable-obj_display","title":"variable obj_display","text":"<pre><code>ASL::cla_display obj_display;\n</code></pre>"},{"location":"DeviceCode/interupt_8cpp/#variable-u8_computer_quantity","title":"variable u8_computer_quantity","text":"<pre><code>uint8_t u8_computer_quantity;\n</code></pre>"},{"location":"DeviceCode/interupt_8cpp/#variable-u8_player_quantity","title":"variable u8_player_quantity","text":"<pre><code>uint8_t u8_player_quantity;\n</code></pre>"},{"location":"DeviceCode/interupt_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"DeviceCode/interupt_8cpp/#function-isr","title":"function ISR","text":"<p>interupt routine for the Choose (green) Button. <pre><code>ISR (\n    INT4_vect\n) \n</code></pre></p> <p>This interupt is used for state manipulation. </p>"},{"location":"DeviceCode/interupt_8cpp/#function-isr_1","title":"function ISR","text":"<p>interupt routine for the Submit (red) Button. <pre><code>ISR (\n    INT5_vect\n) \n</code></pre></p> <p>This interupt is used for state manipulation. </p>"},{"location":"DeviceCode/interupt_8cpp/#function-isr_2","title":"function ISR","text":"<p>interupt routine for the Timer 3. <pre><code>ISR (\n    TIMER3_COMPA_vect\n) \n</code></pre></p> <p>This interupt is used for button debounce. it will be triggered shortly after button interupts to reenable the buttons. </p>"},{"location":"DeviceCode/interupt_8cpp/#function-isr_3","title":"function ISR","text":"<p>interupt routine for the Timer 4. <pre><code>ISR (\n    TIMER4_COMPA_vect\n) \n</code></pre></p> <p>This interupt is used for the display update when using the Blink method. It might just set the bool_blink_flag, if updating the display would take too long for the ISR. </p>"},{"location":"DeviceCode/interupt_8cpp/#function-isr_4","title":"function ISR","text":"<p>interupt routine for the Timer 5. <pre><code>ISR (\n    TIMER5_COMPA_vect\n) \n</code></pre></p> <p>This interupt does nothing except disabling itself. The Delay_256 function will pause and return when this interrupt occurs. </p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/src/interupt.cpp</code></p>"},{"location":"DeviceCode/interupt_8cpp_source/","title":"File interupt.cpp","text":"<p>File List &gt; COD_ENG_OUT_arduino_code &gt; src &gt; interupt.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;ASL.hpp&gt;\n#include &lt;Arduino.h&gt;\n#include &lt;logic.hpp&gt;\n\nextern volatile ASL::en_state en_current_state;\nextern uint8_t u8_player_quantity;\nextern uint8_t u8_computer_quantity;\nextern volatile int8_t i8_current_token_number;\nextern ASL::cla_display obj_display;\nextern volatile bool bool_blink_flag;\n\n#if TIMING_DEBUG_INTERN != 0\nextern uint8_t u8_timing_debug_array[101];\nextern uint8_t u8_timing_debug_counter;\n#endif\n\nISR(INT4_vect) {\n  // Disable INT4:\n  EIMSK &amp;= 0b11101111;\n\n#if TIMING_DEBUG\n  PORTK |= 0b00000001;\n#endif\n#if TIMING_DEBUG_INTERN == 1\n  TCNT2 = 0x00;\n#endif\n\n  switch (en_current_state) {\n  case ASL::display_setup_real_players:\n    // NOP\n    break;\n  case ASL::setup_real_players:\n    en_current_state = ASL::modify_real_player_number;\n    break;\n  case ASL::modify_real_player_number:\n    // NOP\n    break;\n  case ASL::display_setup_computer_players:\n    // NOP\n    break;\n  case ASL::setup_computer_players:\n    en_current_state = ASL::modify_computer_player_number;\n    break;\n  case ASL::modify_computer_player_number:\n    // NOP\n    break;\n  case ASL::display_setup_computer_player_mode:\n    // NOP\n    break;\n  case ASL::setup_computer_player_mode:\n    en_current_state = ASL::modify_computer_player_mode;\n    break;\n  case ASL::modify_computer_player_mode:\n    // NOP\n    break;\n  case ASL::init_game_logic:\n    // NOP\n    break;\n  case ASL::wait_for_dice_roll:\n    en_current_state = ASL::roll_the_dice;\n    break;\n  case ASL::roll_the_dice:\n    // NOP\n    break;\n  case ASL::wait_for_player_input:\n    en_current_state = ASL::validate_token;\n    break;\n  case ASL::display_token:\n    // NOP\n    break;\n  case ASL::validate_token:\n    // NOP\n    break;\n  case ASL::move_token:\n    // NOP\n    break;\n  case ASL::next_player:\n    // NOP\n    break;\n  case ASL::game_finished:\n    en_current_state = ASL::display_setup_real_players;\n    break;\n  default:\n    // An error occured, go back to setup.\n    en_current_state = ASL::display_setup_real_players;\n    break;\n  }\n\n  // Reset the timer. Interupts must be disabled during this task, because it is\n  // a 16 BIT Timer.\n  cli();\n  TCNT3 = 0x0000;\n  sei();\n  // clear Interupt Flag Register for Output compare A\n  TIFR3 = 1 &lt;&lt; OCF3A;\n\n#if TIMING_DEBUG\n  PORTK &amp;= 0b11111110;\n#endif\n#if TIMING_DEBUG_INTERN == 1\n  // write TCNT2 value to array\n  u8_timing_debug_array[u8_timing_debug_counter] = TCNT2;\n  // write next value to next array position\n  u8_timing_debug_counter++;\n#endif\n\n  // Enable Timer interupt\n  TIMSK3 |= 1 &lt;&lt; OCIE3A;\n}\n\nISR(INT5_vect) {\n  // Disable INT5:\n  EIMSK &amp;= 0b11011111;\n\n#if TIMING_DEBUG\n  PORTK |= 0b00000010;\n#endif\n#if TIMING_DEBUG_INTERN == 2\n  TCNT2 = 0x00;\n#endif\n\n  switch (en_current_state) {\n  case ASL::display_setup_real_players:\n    // NOP\n    break;\n  case ASL::setup_real_players:\n    if (u8_player_quantity != 4) {\n      en_current_state = ASL::display_setup_computer_players;\n    } else {\n      en_current_state = ASL::init_game_logic;\n    }\n    break;\n  case ASL::modify_real_player_number:\n    // NOP\n    break;\n  case ASL::display_setup_computer_players:\n    // NOP\n    break;\n  case ASL::setup_computer_players:\n    if (u8_computer_quantity != 0) {\n      en_current_state = ASL::display_setup_computer_player_mode;\n    } else {\n      en_current_state = ASL::init_game_logic;\n    }\n    break;\n  case ASL::modify_computer_player_number:\n    // NOP\n    break;\n  case ASL::display_setup_computer_player_mode:\n    // NOP\n    break;\n  case ASL::setup_computer_player_mode:\n    en_current_state = ASL::init_game_logic;\n    break;\n  case ASL::modify_computer_player_mode:\n    // NOP\n    break;\n  case ASL::init_game_logic:\n    // NOP\n    break;\n  case ASL::wait_for_dice_roll:\n    // NOP\n    break;\n  case ASL::roll_the_dice:\n    // NOP\n    break;\n  case ASL::wait_for_player_input:\n    en_current_state = ASL::move_token;\n    break;\n  case ASL::display_token:\n    // NOP\n    break;\n  case ASL::validate_token:\n    // NOP\n    break;\n  case ASL::move_token:\n    // NOP\n    break;\n  case ASL::next_player:\n    // NOP\n    break;\n  case ASL::game_finished:\n    en_current_state = ASL::display_setup_real_players;\n    break;\n  default:\n    // An error occured, go back to setup.\n    en_current_state = ASL::display_setup_real_players;\n    break;\n  }\n\n  // Reset the timer. Interupts must be disabled during this task, because it is\n  // a 16 BIT Timer.\n  cli();\n  TCNT3 = 0x0000;\n  sei();\n  // clear Interupt Flag Register for Output compare A\n  TIFR3 = 1 &lt;&lt; OCF3A;\n\n#if TIMING_DEBUG\n  PORTK &amp;= 0b11111101;\n#endif\n#if TIMING_DEBUG_INTERN == 2\n  // write TCNT2 value to array\n  u8_timing_debug_array[u8_timing_debug_counter] = TCNT2;\n  // write next value to next array position\n  u8_timing_debug_counter++;\n#endif\n\n  // Enable Timer interupt\n  TIMSK3 |= 1 &lt;&lt; OCIE3A;\n}\n\nISR(TIMER3_COMPA_vect) {\n#if TIMING_DEBUG\n  PORTK |= 0b00000100;\n#endif\n#if TIMING_DEBUG_INTERN == 3\n  TCNT2 = 0x00;\n#endif\n\n  // Disable Timer Interupt:\n  TIMSK3 &amp;= ~(1 &lt;&lt; OCIE3A);\n  // Enable INT4 and INT5:\n  EIMSK |= 0b00110000;\n  // Reset Interupt Flags:\n  EIFR |= 0b00110000;\n\n#if TIMING_DEBUG\n  PORTK &amp;= 0b11111011;\n#endif\n#if TIMING_DEBUG_INTERN == 3\n  // write TCNT2 value to array\n  u8_timing_debug_array[u8_timing_debug_counter] = TCNT2;\n  // write next value to next array position\n  u8_timing_debug_counter++;\n#endif\n}\n\nISR(TIMER4_COMPA_vect) {\n#if TIMING_DEBUG\n  PORTK |= 0b00001000;\n#endif\n#if TIMING_DEBUG_INTERN == 4\n  TCNT2 = 0x00;\n#endif\n\n  bool_blink_flag = obj_display.Blink_Update(true);\n\n#if TIMING_DEBUG\n  PORTK &amp;= 0b11110111;\n#endif\n#if TIMING_DEBUG_INTERN == 4\n  // write TCNT2 value to array\n  u8_timing_debug_array[u8_timing_debug_counter] = TCNT2;\n  // write next value to next array position\n  u8_timing_debug_counter++;\n#endif\n}\n\nISR(TIMER5_COMPA_vect) {\n#if TIMING_DEBUG\n  PORTK |= 0b00010000;\n#endif\n#if TIMING_DEBUG_INTERN == 5\n  TCNT2 = 0x00;\n#endif\n\n  // Disable Timer Interupt:\n  TIMSK5 &amp;= ~(1 &lt;&lt; OCIE5A);\n\n#if TIMING_DEBUG\n  PORTK &amp;= 0b11101111;\n#endif\n#if TIMING_DEBUG_INTERN == 5\n  // write TCNT2 value to array\n  u8_timing_debug_array[u8_timing_debug_counter] = TCNT2;\n  // write next value to next array position\n  u8_timing_debug_counter++;\n#endif\n}\n</code></pre>"},{"location":"DeviceCode/main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; src &gt; main.cpp</p> <p>Go to the source code of this file</p> <p>This file contains the main loop and setup of the game. More...</p> <ul> <li><code>#include &lt;ASL.hpp&gt;</code></li> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;defines.hpp&gt;</code></li> <li><code>#include &lt;logic.hpp&gt;</code></li> </ul>"},{"location":"DeviceCode/main_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name bool bool_blink_flag   = = false ASL::en_state en_current_state   = = ASL::display_setup_real_players int8_t i8_current_player_number int8_t i8_current_token_number ASL::cla_display obj_display LOGIC::cla_session * obj_session uint8_t u8_computer_quantity uint8_t u8_player_quantity"},{"location":"DeviceCode/main_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Move_Token (int8_t _i8_current_player_number, uint8_t _u8_remove_position, uint8_t _u8_add_position, ASL::cla_display * _obj_display, LOGIC::cla_session * _obj_session, uint8_t _u8_player_quantity, uint8_t _u8_dice_value) This function animates the token movement. void loop ()  void setup ()"},{"location":"DeviceCode/main_8cpp/#detailed-description","title":"Detailed Description","text":"<p>In this file, the setup and loop functions are implemented. </p>"},{"location":"DeviceCode/main_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"DeviceCode/main_8cpp/#variable-bool_blink_flag","title":"variable bool_blink_flag","text":"<pre><code>volatile bool bool_blink_flag;\n</code></pre>"},{"location":"DeviceCode/main_8cpp/#variable-en_current_state","title":"variable en_current_state","text":"<pre><code>volatile ASL::en_state en_current_state;\n</code></pre>"},{"location":"DeviceCode/main_8cpp/#variable-i8_current_player_number","title":"variable i8_current_player_number","text":"<pre><code>volatile int8_t i8_current_player_number;\n</code></pre>"},{"location":"DeviceCode/main_8cpp/#variable-i8_current_token_number","title":"variable i8_current_token_number","text":"<pre><code>volatile int8_t i8_current_token_number;\n</code></pre>"},{"location":"DeviceCode/main_8cpp/#variable-obj_display","title":"variable obj_display","text":"<pre><code>ASL::cla_display obj_display(A, B, C, CLK, LAT, OE);\n</code></pre>"},{"location":"DeviceCode/main_8cpp/#variable-obj_session","title":"variable obj_session","text":"<pre><code>LOGIC::cla_session* obj_session;\n</code></pre>"},{"location":"DeviceCode/main_8cpp/#variable-u8_computer_quantity","title":"variable u8_computer_quantity","text":"<pre><code>uint8_t u8_computer_quantity;\n</code></pre>"},{"location":"DeviceCode/main_8cpp/#variable-u8_player_quantity","title":"variable u8_player_quantity","text":"<pre><code>uint8_t u8_player_quantity;\n</code></pre>"},{"location":"DeviceCode/main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"DeviceCode/main_8cpp/#function-move_token","title":"function Move_Token","text":"<p>This function animates the token movement. <pre><code>void Move_Token (\n    int8_t _i8_current_player_number,\n    uint8_t _u8_remove_position,\n    uint8_t _u8_add_position,\n    ASL::cla_display * _obj_display,\n    LOGIC::cla_session * _obj_session,\n    uint8_t _u8_player_quantity,\n    uint8_t _u8_dice_value\n) \n</code></pre></p> <p>This function animates the movement of a token from one position to another.</p> <p>Parameters:</p> <ul> <li><code>_i8_current_player_number</code> The number of the current player. </li> <li><code>_u8_remove_position</code> The start position for the token to start walking. </li> <li><code>_u8_add_position</code> The end position for the token to stop walking. </li> <li><code>_obj_display</code> Pointer to the display object. </li> <li><code>_obj_session</code> Pointer to the session object. </li> <li><code>_u8_player_quantity</code> The number of players. </li> <li><code>_u8_dice_value</code> The distance the token will walk. </li> </ul>"},{"location":"DeviceCode/main_8cpp/#function-loop","title":"function loop","text":"<pre><code>void loop () \n</code></pre>"},{"location":"DeviceCode/main_8cpp/#function-setup","title":"function setup","text":"<pre><code>void setup () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/src/main.cpp</code></p>"},{"location":"DeviceCode/main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; COD_ENG_OUT_arduino_code &gt; src &gt; main.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;ASL.hpp&gt;\n#include &lt;Arduino.h&gt;\n#include &lt;defines.hpp&gt;\n#include &lt;logic.hpp&gt;\n\n// Global Variables, because they are used in the interupt routine or setup\n// function.\nvolatile ASL::en_state en_current_state = ASL::display_setup_real_players;\n// used in ISR (but not changed):\nuint8_t u8_player_quantity;\nuint8_t u8_computer_quantity;\n\n// Use int here, as invalid values are -1\nvolatile int8_t i8_current_player_number;\nvolatile int8_t i8_current_token_number;\n\n// classes\nLOGIC::cla_session *obj_session;\nASL::cla_display obj_display(A, B, C, CLK, LAT, OE);\n\n// Used for blinking\nvolatile bool bool_blink_flag = false;\n\n// Function Prototypes\nextern void Move_Token(int8_t _i8_current_player_number,\n                       uint8_t _u8_remove_position, uint8_t _u8_add_position,\n                       ASL::cla_display *_obj_display,\n                       LOGIC::cla_session *_obj_session,\n                       uint8_t _u8_player_quantity, uint8_t _u8_dice_value);\n\n#if TIMING_DEBUG_INTERN != 0\nvolatile uint8_t u8_timing_debug_array[101];\nvolatile uint8_t u8_timing_debug_counter = 0;\n#endif\n\nvoid setup() {\n  obj_display.Set_Colors(0, RED_BRIGHT, RED_DARK);\n  obj_display.Set_Colors(1, BLUE_BRIGHT, BLUE_DARK);\n  obj_display.Set_Colors(2, YELLOW_BRIGHT, YELLOW_DARK);\n  obj_display.Set_Colors(3, GREEN_BRIGHT, GREEN_DARK);\n  obj_display.Begin();\n  ASL::Setup_Buttons();\n  ASL::Setup_Dice();\n#if DEBUG || TIMING_DEBUG\n  // Set Port K to Output\n  DDRK = 0xff;\n#endif\n#if TIMING_DEBUG_INTERN != 0\n  // Set Timer 2 to prescaler 0\n  TCCR2A = 0x00;\n  TCCR2B = 0x00;\n  TCCR2B |= (1 &lt;&lt; CS20);\n  Serial.begin(9600);\n#endif\n}\n\nvoid loop() {\n  // Variables used to check if the new position is occupied\n  static uint8_t u8_occupying_player;\n  static uint8_t u8_occupying_token;\n  static bool bool_occupied_flag;\n\n  // dice variables\n  static uint8_t u8_dice_value;\n  static uint8_t u8_dice_roll_counter;\n\n  // player setup variables\n  static LOGIC::mode en_computer_mode;\n\n  static uint8_t u8_old_position;\n  static uint8_t u8_new_position;\n  switch (en_current_state) {\n  // -----------------------------------------------------------------------------\n  case ASL::display_setup_real_players:\n    // ...........................................................................\n    // .............................INITIALIZATION................................\n    // ...........................................................................\n    // This is the first state, so we will set some initial values here.\n    u8_dice_value = INITIAL_DICE_VALUE;\n    u8_dice_roll_counter = INITIAL_DICE_ROLL_COUNTER;\n    en_computer_mode = INITIAL_COMPUTER_MODE;\n    u8_player_quantity = INITIAL_PLAYER_QUANTITY;\n    u8_computer_quantity = INITIAL_COMPUTER_QUANTITY;\n    i8_current_player_number = INITIAL_CURRENT_PLAYER_NUMBER;\n    i8_current_token_number = INITIAL_CURRENT_TOKEN_NUMBER;\n    bool_blink_flag = INITIAL_BOOL_BLINK_FLAG;\n    // ...........................................................................\n    if (obj_display.Blink_Is_On()) {\n      obj_display.Blink_Stop();\n    }\n    obj_display.Display_Restore();\n    obj_display.Display_Players(u8_player_quantity);\n    obj_display.Display_Char('R', 'E', 'A');\n    en_current_state = ASL::setup_real_players;\n    break;\n  // -----------------------------------------------------------------------------\n  case ASL::setup_real_players:\n    // NOP\n    break;\n  // -----------------------------------------------------------------------------\n  case ASL::modify_real_player_number:\n    if (u8_player_quantity &lt; 4) {\n      u8_player_quantity++;\n    } else {\n      u8_player_quantity = 0;\n    }\n    obj_display.Display_Players(u8_player_quantity);\n#if DEBUG\n    // First 4 Bits are for the current state, two for the player quantity and\n    // two for computer quantity\n    PORTK = en_current_state | ((u8_player_quantity - 1) &lt;&lt; 4) |\n            (u8_computer_quantity &lt;&lt; 6);\n#endif\n    en_current_state = ASL::setup_real_players;\n    break;\n  // -----------------------------------------------------------------------------\n  case ASL::display_setup_computer_players:\n    obj_display.Display_Players(u8_player_quantity);\n    obj_display.Display_Char('C', 'O', 'M');\n    en_current_state = ASL::setup_computer_players;\n    break;\n  // -----------------------------------------------------------------------------\n  case ASL::setup_computer_players:\n    // NOP\n    break;\n  // -----------------------------------------------------------------------------\n  case ASL::modify_computer_player_number:\n    if (u8_player_quantity &lt; 4) {\n      u8_player_quantity++;\n      u8_computer_quantity++;\n    } else {\n      u8_player_quantity = u8_player_quantity - u8_computer_quantity;\n      u8_computer_quantity = 0;\n    }\n    obj_display.Display_Players(u8_player_quantity);\n#if DEBUG\n    // First 4 Bits are for the current state, two for the player quantity and\n    // two for computer quantity\n    PORTK = en_current_state | ((u8_player_quantity - 1) &lt;&lt; 4) |\n            (u8_computer_quantity &lt;&lt; 6);\n#endif\n    en_current_state = ASL::setup_computer_players;\n    break;\n  // -----------------------------------------------------------------------------\n  case ASL::display_setup_computer_player_mode:\n    obj_display.Display_Char('S', 'T', 'U');\n    en_current_state = ASL::setup_computer_player_mode;\n    break;\n  case ASL::setup_computer_player_mode:\n    // display mode.\n    break;\n  // -----------------------------------------------------------------------------\n  case ASL::modify_computer_player_mode:\n    // modify the computer player mode\n    switch (en_computer_mode) {\n    case LOGIC::Student:\n      en_computer_mode = LOGIC::Professor;\n      obj_display.Display_Char('P', 'R', 'O');\n      break;\n    case LOGIC::Professor:\n      en_computer_mode = LOGIC::Student;\n      obj_display.Display_Char('S', 'T', 'U');\n      break;\n    }\n    // Go back to setup state\n    en_current_state = ASL::setup_computer_player_mode;\n    break;\n  // -----------------------------------------------------------------------------\n  case ASL::init_game_logic:\n    // remove txt from display\n    obj_display.Display_Char();\n    obj_session = new LOGIC::cla_session(\n        u8_player_quantity, u8_computer_quantity, en_computer_mode);\n#if DEBUG\n    // First 4 Bits are for the current state, two for the player quantity and\n    // two for computer quantity\n    PORTK = en_current_state | ((u8_player_quantity - 1) &lt;&lt; 4) |\n            (u8_computer_quantity &lt;&lt; 6);\n#endif\n    obj_display.Display_Current_Player(i8_current_player_number);\n    if (u8_player_quantity != u8_computer_quantity) {\n      // Only wait for dice roll, if there are real players\n      en_current_state = ASL::wait_for_dice_roll;\n    } else {\n      // Set the player number to minus one: In next_player state, the next\n      // player is chosen by adding one to the current player number, and we\n      // want to start at player 0.\n      i8_current_player_number = -1;\n      en_current_state = ASL::next_player;\n    }\n    break;\n  // -----------------------------------------------------------------------------\n  case ASL::wait_for_dice_roll:\n    // NOP\n    break;\n  // -----------------------------------------------------------------------------\n  case ASL::roll_the_dice:\n    u8_dice_value = ASL::Roll_Dice();\n    u8_dice_roll_counter--;\n    obj_display.Display_Dice(u8_dice_value, u8_dice_roll_counter,\n                             i8_current_player_number);\n    // You can roll the dice up to 3 times, when all your tokens are still in\n    // the Starting Square and you did not get a 6.\n    if ((obj_session-&gt;array_players[i8_current_player_number]\n             -&gt;Get_Player_Status() == LOGIC::Start) &amp;&amp;\n        (u8_dice_roll_counter &gt;= 1) &amp;&amp; (u8_dice_value != 6)) {\n      // one more chance for the same player\n      en_current_state = ASL::wait_for_dice_roll;\n    } else if ((obj_session-&gt;array_players[i8_current_player_number]\n                    -&gt;Get_Player_Status() == LOGIC::Start) &amp;&amp;\n               u8_dice_roll_counter &lt;= 0 &amp;&amp; u8_dice_value != 6) {\n      // If you did not get a 6 and dice roll counter is 0,\n      // wait for next player to roll dice\n      en_current_state = ASL::next_player;\n    } else if (u8_dice_value == 6) {\n      // If you got a 6, your token is moved out of the Starting Square\n      en_current_state = ASL::validate_token;\n      u8_dice_roll_counter = 1;\n    } else {\n      // If you got a number between 1 and 5, you can move a token\n      en_current_state = ASL::validate_token;\n    }\n#if DEBUG\n    PORTK = en_current_state | (i8_current_player_number &lt;&lt; 4) |\n            (i8_current_token_number &lt;&lt; 6);\n    ;\n#endif\n    break;\n  // -----------------------------------------------------------------------------\n  case ASL::wait_for_player_input:\n    // NOP\n    break;\n  // -----------------------------------------------------------------------------\n  case ASL::display_token: {\n    // First, stop previous blinking, if it was blinking.\n    obj_display.Blink_Stop();\n    // Start blinking the token\n    obj_display.Blink_Start(ASL::slow, BLINK_CYCLES_TOKEN, ASL::token,\n                            i8_current_player_number, u8_occupying_player,\n                            u8_new_position, bool_occupied_flag,\n                            u8_old_position);\n\n#if DEBUG\n    PORTK = en_current_state | (i8_current_player_number &lt;&lt; 4) |\n            (i8_current_token_number &lt;&lt; 6);\n#endif\n    en_current_state = ASL::wait_for_player_input;\n  } break;\n  // -----------------------------------------------------------------------------\n  case ASL::validate_token: {\n    if (i8_current_token_number &lt; 3) {\n      i8_current_token_number++;\n    } else {\n      i8_current_token_number = 0;\n    }\n#if DEBUG\n    PORTK = en_current_state | (i8_current_player_number &lt;&lt; 4) |\n            (i8_current_token_number &lt;&lt; 6);\n#endif\n    // Lets get the current player state, so we don't have to do it several\n    // times in the else if statement.\n    LOGIC::status en_player_state =\n        obj_session-&gt;array_players[i8_current_player_number]\n            -&gt;Get_Player_Status();\n    // check if a token must be moved from starting square\n    if (obj_session-&gt;array_players[i8_current_player_number]\n            -&gt;Is_Start_Field_Occupied_By_Own_Token() != -1) {\n      i8_current_token_number =\n          obj_session-&gt;array_players[i8_current_player_number]\n              -&gt;Is_Start_Field_Occupied_By_Own_Token();\n      en_current_state = ASL::move_token;\n    } else if ((u8_dice_value == 6) &amp;&amp;\n               ((en_player_state == LOGIC::Start) ||\n                (en_player_state == LOGIC::Start_Track) ||\n                (en_player_state == LOGIC::Start_Finished) ||\n                (en_player_state == LOGIC::Start_Track_Finished))) {\n      // if a 6 was rolled and there are still token in the starting square, the\n      // player cannot choose a token to move, so lets look for a token in the\n      // starting square\n      i8_current_token_number = 0;\n      while (obj_session-&gt;array_players[i8_current_player_number]\n                 -&gt;Get_Token_Position(i8_current_token_number) &gt;= 5) {\n        // increase token number as long as the token is not in the starting\n        // square\n        i8_current_token_number++;\n      }\n      en_current_state = ASL::move_token;\n    }\n    // if no specific token must be moved, check if any token can be moved\n    else {\n      // variable used to determine how many token can be moved\n      uint8_t u8_token_counter = 0;\n      // variable used to determine the next movable Token\n      int8_t u8_next_movable_token = -1;\n      // check how many tokens can be moved:\n      for (uint8_t i = 0; i &lt; 4; i++) {\n        if (obj_session-&gt;array_players[i8_current_player_number]\n                -&gt;Calculate_Possible_Position(i, u8_dice_value) !=\n            obj_session-&gt;array_players[i8_current_player_number]\n                -&gt;Get_Token_Position(i)) {\n          u8_token_counter++;\n          // determine the next movable token\n          if (u8_next_movable_token == -1) {\n            // if it is -1, no token was found yet, so use the current token\n            u8_next_movable_token = i;\n          } else if ((u8_next_movable_token &lt; i8_current_token_number) &amp;&amp;\n                     (i &gt;= i8_current_token_number)) {\n            // we want the smallest token number that is larger than the current\n            // token number, if there is one.\n            u8_next_movable_token = i;\n          }\n        }\n      }\n      // set current token number to the next movable token\n      i8_current_token_number = u8_next_movable_token;\n      // handle cases of tokens that can be moved.\n      if (u8_token_counter == 0) {\n        // If no token can be moved, next player is chosen\n        en_current_state = ASL::next_player;\n      } else if (u8_token_counter == 1) {\n        // If only one token can be moved, it is chosen and moved.\n        en_current_state = ASL::move_token;\n      } else {\n        // If more than one token can be moved, display it, so the Player can\n        // Choose.\n        en_current_state = ASL::display_token;\n      }\n    }\n    // check if the new position is occupied and set the occupied flag\n    // accordingly.\n    bool_occupied_flag = obj_session-&gt;Is_Occupied(\n        u8_occupying_player, u8_occupying_token,\n        obj_session-&gt;array_players[i8_current_player_number]\n            -&gt;Calculate_Possible_Position(i8_current_token_number,\n                                          u8_dice_value));\n    // Get the old and new position of the token.\n    u8_old_position = obj_session-&gt;array_players[i8_current_player_number]\n                          -&gt;Get_Token_Position(i8_current_token_number);\n    u8_new_position = obj_session-&gt;array_players[i8_current_player_number]\n                          -&gt;Calculate_Possible_Position(i8_current_token_number,\n                                                        u8_dice_value);\n  } break;\n  // -----------------------------------------------------------------------------\n  case ASL::move_token: {\n    obj_display.Blink_Stop();\n    // move the token on the display\n    if (u8_old_position &gt;= 5) {\n      Move_Token(i8_current_player_number, u8_old_position, u8_new_position,\n                 &amp;obj_display, obj_session, u8_player_quantity, u8_dice_value);\n    } else {\n      obj_display.Move_Token(i8_current_player_number, u8_old_position,\n                             u8_new_position);\n    }\n    // move the token in the logic (must be done before setting the occupied\n    // token, because the new position is set here.)\n    obj_session-&gt;array_players[i8_current_player_number]-&gt;Move_Token(\n        i8_current_token_number, u8_dice_value);\n    // Move the occupying token on the display, if needed.\n    if (bool_occupied_flag) {\n      obj_display.Move_Token(\n          u8_occupying_player, u8_new_position,\n          obj_session-&gt;array_players[u8_occupying_player]-&gt;Get_Token_Position(\n              u8_occupying_token));\n      obj_display.Blink_Start(ASL::fast, BLINK_CYCLES_OCCUPIED_TOKEN,\n                              ASL::token_thrown, i8_current_player_number,\n                              u8_occupying_player, u8_new_position);\n      bool_occupied_flag = false;\n    }\n    // determine the next state\n    if (u8_dice_roll_counter &gt;= 1) {\n      en_current_state = ASL::wait_for_dice_roll;\n    } else {\n      en_current_state = ASL::next_player;\n    }\n  } break;\n  // -----------------------------------------------------------------------------\n  case ASL::next_player: {\n    if (obj_session-&gt;array_players[i8_current_player_number]\n            -&gt;Get_Player_Status() == LOGIC::Finished) {\n      // clear the right half of the display\n      obj_display.Display_Clear_Right();\n      // Start winner animation\n      obj_display.Display_Progress(i8_current_player_number, 28);\n      obj_display.Blink_Start(ASL::slow, BLINK_CYCLES_WINNER_ANIMATION,\n                              ASL::winner_animation, i8_current_player_number,\n                              BLINK_CYCLES_WINNER_ANIMATION);\n      delete obj_session;\n      en_current_state = ASL::game_finished;\n      break;\n    } else {\n      if (i8_current_player_number &lt; (u8_player_quantity - 1)) {\n        i8_current_player_number++;\n      } else {\n        i8_current_player_number = 0;\n      }\n      // Calculate transfer parameter for display current player\n      int8_t i8_tokens_at_home = 0;\n      for (uint8_t i = 0; i &lt; 4; i++) {\n        if (obj_session-&gt;array_players[i8_current_player_number]\n                -&gt;Get_Token_Position(i) &lt; 5) {\n          i8_tokens_at_home |= (1 &lt;&lt; i);\n        }\n      }\n      // before the current player can be displayed, blinking animation (throw)\n      // must be finished. Otherwise the wrong token might be displayed on the\n      // position somebody was thrown from, because the blinking is restarted in\n      // another mode (starting_square) and the Blink_Stop() method was never\n      // called. This could lead to the wrong token being displayed, since the\n      // position is alternating in the two colors. If the blinking gets\n      // disrupted while the thrown token is displayed, the wrong token stays\n      // displayed.\n      while (obj_display.Blink_Is_On()) {\n        // Wait for blinking animation to finish, so the thrown animation isn't\n        // getting messed up by the next player's starting square blinking.\n        // If no token was thrown, Blink_Is_On will immediatly return false and\n        // the loop will never be executed.\n        asm volatile(\"nop\"); // Do nothing\n      }\n      obj_display.Display_Current_Player(i8_current_player_number,\n                                         i8_tokens_at_home);\n      // Display the progress bar:\n      obj_display.Display_Progress(\n          i8_current_player_number,\n          obj_session-&gt;array_players[i8_current_player_number]\n              -&gt;Get_Player_Progress());\n      //  Set the dice roll counter for the next player:\n      if (obj_session-&gt;array_players[i8_current_player_number]\n              -&gt;Get_Player_Status() == LOGIC::Start) {\n        // roll the dice 3 times\n        u8_dice_roll_counter = DICE_ROLLS_AT_START;\n      } else {\n        // roll the dice 1 time (unless you get a 6)\n        u8_dice_roll_counter = DICE_ROLLS_NORMAL;\n      }\n      en_current_state = ASL::wait_for_dice_roll;\n      while (obj_display.Blink_Is_On()) {\n        // Wait for blinking animation to finish, so the starting square isn't\n        // getting messed up by the player leaving the starting square.\n        asm volatile(\"nop\"); // Do nothing\n      }\n      // ------ Auto-move if we have a computer player ---------\n      if (obj_session-&gt;array_players[i8_current_player_number]-&gt;Is_Computer()) {\n        while (u8_dice_roll_counter &gt; 0) {\n          // Computer code here\n          u8_dice_value = ASL::Roll_Dice();\n          if (u8_dice_value == 6) {\n            u8_dice_roll_counter = DICE_ROLLS_AT_SIX;\n          } else {\n            u8_dice_roll_counter--;\n          }\n          obj_display.Display_Dice(u8_dice_value, u8_dice_roll_counter,\n                                   i8_current_player_number);\n          ASL::Delay_256(ANIMATION_SPEED_COMPUTER);\n          i8_current_token_number =\n              obj_session-&gt;array_players[i8_current_player_number]-&gt;Auto_Move(\n                  u8_dice_value, bool_occupied_flag, u8_old_position);\n          u8_new_position = obj_session-&gt;array_players[i8_current_player_number]\n                                -&gt;Get_Token_Position(i8_current_token_number);\n          if (i8_current_token_number != -1) {\n            // move the token on the display\n            if (u8_old_position &gt;= 5) {\n              Move_Token(i8_current_player_number, u8_old_position,\n                         u8_new_position, &amp;obj_display, obj_session,\n                         u8_player_quantity, u8_dice_value);\n            } else {\n              obj_display.Move_Token(i8_current_player_number, u8_old_position,\n                                     u8_new_position);\n            }\n          }\n          if (bool_occupied_flag) {\n            u8_occupying_player = obj_session-&gt;u8_is_occupied_player_id;\n            u8_occupying_token = obj_session-&gt;u8_is_occupied_token_number;\n            obj_display.Move_Token(\n                u8_occupying_player, u8_new_position,\n                obj_session-&gt;array_players[u8_occupying_player]\n                    -&gt;Get_Token_Position(u8_occupying_token));\n            obj_display.Blink_Start(ASL::fast, BLINK_CYCLES_OCCUPIED_TOKEN,\n                                    ASL::token_thrown, i8_current_player_number,\n                                    u8_occupying_player, u8_new_position);\n            bool_occupied_flag = false;\n          }\n          if (u8_dice_roll_counter &gt; 0) {\n            ASL::Delay_256(ANIMATION_SPEED_COMPUTER);\n          }\n#if DEBUG\n          PORTK = en_current_state | ((i8_current_player_number &lt;&lt; 4) &amp;&amp; 0x0f) |\n                  ((i8_current_token_number &lt;&lt; 6) &amp;&amp; 0x0f);\n#endif\n          en_current_state = ASL::next_player;\n        }\n      }\n    }\n    // Reset the token number for the next player\n    i8_current_token_number = 0;\n  } break;\n  // -----------------------------------------------------------------------------\n  case ASL::game_finished:\n    asm volatile(\"nop\"); // Do nothing\n    break;\n  default:\n    // An error occured, go back to setup.\n    en_current_state = ASL::display_setup_real_players;\n    break;\n  }\n  // ------------------------------Blinking--------------------------------------\n  if (bool_blink_flag) {\n    obj_display.Blink_Update(false);\n    bool_blink_flag = false;\n  }\n#if TIMING_DEBUG_INTERN != 0\n  if (u8_timing_debug_counter &gt; TIMING_DEBUG_COUNT_TO) {\n    obj_display.obj_matrix-&gt;dumpMatrix();\n    Serial.println(\"--------------------\");\n    for (uint8_t i = 0; i &lt; TIMING_DEBUG_COUNT_TO; i++) {\n      Serial.print(u8_timing_debug_array[i]);\n      Serial.print(\" \");\n    }\n  }\n#endif\n}\n</code></pre>"},{"location":"DeviceCode/dir_02c5495a4fec5d88110fd511c5e276ee/","title":"Dir test","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; test</p>"},{"location":"DeviceCode/dir_02c5495a4fec5d88110fd511c5e276ee/#files","title":"Files","text":"Type Name file 001-TestCase_Requirements.cpp This file contains the test cases for the requirements of the game logic. file 002-TestCase_ComputerPlayer.cpp Test cases for the computer player. file 003-TestCase_Session_and_Player.cpp Test cases for various situations during a game. file marked_dice.hpp This file contains the dice values for the test cases. <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/test/</code></p>"},{"location":"DeviceCode/001-TestCase__Requirements_8cpp/","title":"File 001-TestCase_Requirements.cpp","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; test &gt; 001-TestCase_Requirements.cpp</p> <p>Go to the source code of this file</p> <p>This file contains the test cases for the requirements of the game logic. More...</p> <ul> <li><code>#include &lt;catch2/catch_test_macros.hpp&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;logic.hpp&gt;</code></li> </ul>"},{"location":"DeviceCode/001-TestCase__Requirements_8cpp/#public-functions","title":"Public Functions","text":"Type Name TEST_CASE (\"Test Move_Token_Kick\", \"\")  TEST_CASE (\"Test Home_Position\", \"\")  TEST_CASE (\"Test Get_Player_Status\", \"\")  TEST_CASE (\"Test occupied flag in Auto_Move\", \"\")  TEST_CASE (\"Test occupied flag in Auto_Move with start position\", \"\")  TEST_CASE (\"Test Move into Finish\", \"\")  TEST_CASE (\"Test Kick_Token_From_Start_Position\", \"\")  TEST_CASE (\"Test Skip_And_Kick_Tokens\", \"\")  TEST_CASE (\"Test if player throws himself (Requirement 54)\", \"\")  TEST_CASE (\"Test if player throws himself in and before finish (Requirement 54)\", \"\")"},{"location":"DeviceCode/001-TestCase__Requirements_8cpp/#detailed-description","title":"Detailed Description","text":"<p>This file contains multiple game situations and checks if the game logic behaves as expected and as defined in the requirements. </p>"},{"location":"DeviceCode/001-TestCase__Requirements_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"DeviceCode/001-TestCase__Requirements_8cpp/#function-test_case","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test Move_Token_Kick\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/001-TestCase__Requirements_8cpp/#function-test_case_1","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test Home_Position\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/001-TestCase__Requirements_8cpp/#function-test_case_2","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test Get_Player_Status\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/001-TestCase__Requirements_8cpp/#function-test_case_3","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test occupied flag in Auto_Move\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/001-TestCase__Requirements_8cpp/#function-test_case_4","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test occupied flag in Auto_Move with start position\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/001-TestCase__Requirements_8cpp/#function-test_case_5","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test Move into Finish\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/001-TestCase__Requirements_8cpp/#function-test_case_6","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test Kick_Token_From_Start_Position\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/001-TestCase__Requirements_8cpp/#function-test_case_7","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test Skip_And_Kick_Tokens\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/001-TestCase__Requirements_8cpp/#function-test_case_8","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test if player throws himself (Requirement 54)\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/001-TestCase__Requirements_8cpp/#function-test_case_9","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test if player throws himself in and before finish (Requirement 54)\",\n    \"\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/test/001-TestCase_Requirements.cpp</code></p>"},{"location":"DeviceCode/001-TestCase__Requirements_8cpp_source/","title":"File 001-TestCase_Requirements.cpp","text":"<p>File List &gt; COD_ENG_OUT_arduino_code &gt; test &gt; 001-TestCase_Requirements.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;logic.hpp&gt;\n\n// Requirement 44: \"Landet ein Benutzer mit seiner Spielfigur auf einem bereits\n// von einem anderen Benutzer besetzten Feld, so schmei\u00dft er diesen automatisch\"\n\nTEST_CASE(\"Test Move_Token_Kick\", \"[cla_player]\") {\n  LOGIC::cla_session game(4, 0, LOGIC::Student);\n  game.array_players[0]-&gt;Set_Token_Position(2, 29);\n  game.array_players[1]-&gt;Set_Token_Position(1, 25);\n  game.array_players[0]-&gt;Move_Token(2, 1);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(2) == 30);\n  game.array_players[1]-&gt;Move_Token(1, 5);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(2) == 3);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 30);\n}\n\n// Requirement 46: \"Zu Beginn befinden sich alle Figuren in den H\u00e4usern\"\nTEST_CASE(\"Test Home_Position\", \"[cla_player]\") {\n  LOGIC::cla_session game(4, 0, LOGIC::Student);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 1);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 2);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(2) == 3);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(3) == 4);\n\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 1);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 2);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(2) == 3);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(3) == 4);\n\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(0) == 1);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(1) == 2);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(2) == 3);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(3) == 4);\n\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(0) == 1);\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(1) == 2);\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(2) == 3);\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(3) == 4);\n}\n\n// Test Get_Player_Status\nTEST_CASE(\"Test Get_Player_Status\", \"[cla_player]\") {\n  LOGIC::cla_session game(4, 2, LOGIC::Student);\n  game.array_players[0]-&gt;Set_Token_Position(0, 45);\n  game.array_players[0]-&gt;Set_Token_Position(1, 48);\n  game.array_players[0]-&gt;Set_Token_Position(2, 46);\n  game.array_players[0]-&gt;Set_Token_Position(3, 47);\n  REQUIRE(game.array_players[0]-&gt;Get_Player_Status() == LOGIC::Finished);\n\n  game.array_players[1]-&gt;Set_Token_Position(0, 1);\n  game.array_players[1]-&gt;Set_Token_Position(1, 2);\n  game.array_players[1]-&gt;Set_Token_Position(2, 3);\n  game.array_players[1]-&gt;Set_Token_Position(3, 4);\n  REQUIRE(game.array_players[1]-&gt;Get_Player_Status() == LOGIC::Start);\n\n  game.array_players[2]-&gt;Set_Token_Position(0, 45);\n  game.array_players[2]-&gt;Set_Token_Position(1, 24);\n  game.array_players[2]-&gt;Set_Token_Position(2, 46);\n  game.array_players[2]-&gt;Set_Token_Position(3, 47);\n  REQUIRE(game.array_players[2]-&gt;Get_Player_Status() == LOGIC::Track_Finished);\n\n  game.array_players[3]-&gt;Set_Token_Position(0, 35);\n  game.array_players[3]-&gt;Set_Token_Position(1, 36);\n  game.array_players[3]-&gt;Set_Token_Position(2, 37);\n  game.array_players[3]-&gt;Set_Token_Position(3, 38);\n  REQUIRE(game.array_players[3]-&gt;Get_Player_Status() == LOGIC::Track);\n  REQUIRE(game.array_players[3]-&gt;Get_Player_Status() != LOGIC::Start_Track);\n  REQUIRE(game.array_players[3]-&gt;Get_Player_Status() != LOGIC::Start_Finished);\n  REQUIRE(game.array_players[3]-&gt;Get_Player_Status() !=\n          LOGIC::Start_Track_Finished);\n}\n\n// Test occuppied flag in Auto Move\nTEST_CASE(\"Test occupied flag in Auto_Move\", \"[cla_player]\") {\n  bool bool_occupied = false;\n  uint8_t u8_old_position = 0;\n  LOGIC::cla_session game(2, 1, LOGIC::Student);\n  game.array_players[0]-&gt;Move_Token(0, 6);\n  game.array_players[0]-&gt;Move_Token(0, 6);\n  game.array_players[0]-&gt;Move_Token(0, 5);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 16);\n  game.array_players[1]-&gt;Auto_Move(6, bool_occupied, u8_old_position);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 15);\n  REQUIRE(bool_occupied == false);\n  game.array_players[1]-&gt;Auto_Move(1, bool_occupied, u8_old_position);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 16);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 1);\n  REQUIRE(bool_occupied == true);\n}\n\n// Test occuppied flag in Auto Move with start position\nTEST_CASE(\"Test occupied flag in Auto_Move with start position\",\n          \"[cla_player]\") {\n  bool bool_occupied = false;\n  uint8_t u8_old_position = 0;\n  LOGIC::cla_session game(2, 1, LOGIC::Student);\n  game.array_players[0]-&gt;Move_Token(0, 6);\n  game.array_players[0]-&gt;Move_Token(0, 6);\n  game.array_players[0]-&gt;Move_Token(0, 4);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 15);\n  game.array_players[1]-&gt;Auto_Move(6, bool_occupied, u8_old_position);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 15);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 1);\n  REQUIRE(bool_occupied == true);\n  game.array_players[1]-&gt;Auto_Move(1, bool_occupied, u8_old_position);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 16);\n  REQUIRE(bool_occupied == false);\n}\n\n// Requirement  52: \"Erreicht eine Spielfigur das Endfeld, so begibt sie sich\n// mit den \u00fcbrigen, gew\u00fcrfelten Felder ins Ziel\"\nTEST_CASE(\"Test Move into Finish\", \"[cla_player]\") {\n  LOGIC::cla_session game(4, 0, LOGIC::Student);\n\n  // Player 0\n  game.array_players[0]-&gt;Set_Token_Position(0, 40);\n  game.array_players[0]-&gt;Set_Token_Position(1, 41);\n  game.array_players[0]-&gt;Set_Token_Position(2, 42);\n  game.array_players[0]-&gt;Set_Token_Position(3, 43);\n  game.array_players[0]-&gt;Move_Token(0, 5);\n  game.array_players[0]-&gt;Move_Token(1, 5);\n  game.array_players[0]-&gt;Move_Token(2, 5);\n  game.array_players[0]-&gt;Move_Token(3, 5);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 45);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 46);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(2) == 47);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(3) == 48);\n\n  // Player 1\n  game.array_players[1]-&gt;Set_Token_Position(0, 10);\n  game.array_players[1]-&gt;Set_Token_Position(1, 11);\n  game.array_players[1]-&gt;Set_Token_Position(2, 12);\n  game.array_players[1]-&gt;Set_Token_Position(3, 13);\n  game.array_players[1]-&gt;Move_Token(0, 6);\n  game.array_players[1]-&gt;Move_Token(1, 6);\n  game.array_players[1]-&gt;Move_Token(2, 3);\n  game.array_players[1]-&gt;Move_Token(3, 5);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 46);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 47);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(2) == 45);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(3) == 48);\n\n  // Player 2\n  game.array_players[2]-&gt;Set_Token_Position(0, 24);\n  game.array_players[2]-&gt;Set_Token_Position(1, 21);\n  game.array_players[2]-&gt;Set_Token_Position(2, 22);\n  game.array_players[2]-&gt;Set_Token_Position(3, 23);\n  game.array_players[2]-&gt;Move_Token(0, 4);\n  game.array_players[2]-&gt;Move_Token(1, 6);\n  game.array_players[2]-&gt;Move_Token(2, 4);\n  game.array_players[2]-&gt;Move_Token(3, 2);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(0) == 48);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(1) == 47);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(2) == 46);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(3) == 45);\n\n  // Player 3\n  game.array_players[3]-&gt;Set_Token_Position(0, 33);\n  game.array_players[3]-&gt;Set_Token_Position(1, 31);\n  game.array_players[3]-&gt;Set_Token_Position(2, 32);\n  game.array_players[3]-&gt;Set_Token_Position(3, 34);\n  game.array_players[3]-&gt;Move_Token(0, 2);\n  game.array_players[3]-&gt;Move_Token(1, 6);\n  game.array_players[3]-&gt;Move_Token(2, 6);\n  game.array_players[3]-&gt;Move_Token(3, 2);\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(0) == 45);\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(1) == 47);\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(2) == 48);\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(3) == 46);\n}\n\n// Requirement 59: \"Befindet sich eine fremde Figur auf dem eigenen Startfeld,\n// so wird diese geschmissen falls man eine eigene Figur aus dem Haus bringt\"\n\nTEST_CASE(\"Test Kick_Token_From_Start_Position\", \"[cla_player]\") {\n  LOGIC::cla_session game(4, 0, LOGIC::Student);\n  game.array_players[0]-&gt;Set_Token_Position(1, 15);\n  game.array_players[1]-&gt;Set_Token_Position(1, 25);\n  game.array_players[2]-&gt;Set_Token_Position(1, 35);\n  game.array_players[3]-&gt;Set_Token_Position(1, 5);\n  game.array_players[0]-&gt;Move_Token(0, 6);\n  game.array_players[1]-&gt;Move_Token(0, 6);\n  game.array_players[2]-&gt;Move_Token(0, 6);\n  game.array_players[3]-&gt;Move_Token(0, 6);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 5);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 15);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(0) == 25);\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(0) == 35);\n\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 2);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 2);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(1) == 2);\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(1) == 2);\n}\n\n// Requirement 55: \"Spielfiguren werden \u00fcbersprungen, au\u00dfer sie befinden sich\n// auf dem letzten Feld des Spielzugs\"\nTEST_CASE(\"Test Skip_And_Kick_Tokens\", \"[cla_player]\") {\n  LOGIC::cla_session game(4, 0, LOGIC::Student);\n  game.array_players[0]-&gt;Set_Token_Position(1, 15);\n  game.array_players[0]-&gt;Set_Token_Position(2, 16);\n  game.array_players[1]-&gt;Set_Token_Position(1, 19);\n  game.array_players[2]-&gt;Set_Token_Position(1, 17);\n  game.array_players[3]-&gt;Set_Token_Position(1, 18);\n  game.array_players[0]-&gt;Move_Token(1, 4);\n\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 19);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(2) == 16);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 2);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(1) == 17);\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(1) == 18);\n}\n\n// Requirement 54: \"Ein Spielzug bei dem ein Spieler mit seiner Spiellfigur auf\n// einem von sich selbst besetztem Feld landet, kann nicht ausgef\u00fchrt werden\"\n\n// Test if player throws himself out of the game after start and on the field\nTEST_CASE(\"Test if player throws himself (Requirement 54)\", \"[cla_player]\") {\n  LOGIC::cla_session game(2, 1, LOGIC::Student);\n  bool bool_is_occupied;\n  uint8_t u8_old_position;\n\n  game.array_players[0]-&gt;Move_Token(0, 6);\n  game.array_players[0]-&gt;Move_Token(1, 6);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 5);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 2);\n  game.array_players[0]-&gt;Move_Token(0, 4);\n  game.array_players[0]-&gt;Move_Token(1, 6);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 9);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 5);\n  game.array_players[0]-&gt;Move_Token(1, 4);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 5);\n\n  game.array_players[1]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n  game.array_players[1]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 21);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 2);\n  game.array_players[1]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n  game.array_players[1]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 21);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 15);\n  game.array_players[1]-&gt;Auto_Move(4, bool_is_occupied, u8_old_position);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 19);\n}\n\n// Test if player throws himself out of the game in and before finish\nTEST_CASE(\"Test if player throws himself in and before finish (Requirement 54)\",\n          \"[cla_player]\") {\n  LOGIC::cla_session game(2, 1, LOGIC::Student);\n  bool bool_is_occupied;\n  uint8_t u8_old_position;\n\n  game.array_players[0]-&gt;Set_Token_Position(0, 46);\n  game.array_players[0]-&gt;Set_Token_Position(1, 44);\n  game.array_players[0]-&gt;Set_Token_Position(2, 43);\n  game.array_players[0]-&gt;Set_Token_Position(3, 45);\n  game.array_players[0]-&gt;Move_Token(2, 4);\n  game.array_players[0]-&gt;Move_Token(1, 3);\n  game.array_players[0]-&gt;Move_Token(0, 2);\n  game.array_players[0]-&gt;Move_Token(3, 3);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 48);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 44);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(2) == 47);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(3) == 45);\n\n  game.array_players[1]-&gt;Set_Token_Position(0, 46);\n  game.array_players[1]-&gt;Set_Token_Position(1, 14);\n  game.array_players[1]-&gt;Set_Token_Position(2, 13);\n  game.array_players[1]-&gt;Set_Token_Position(3, 45);\n\n  game.array_players[1]-&gt;Auto_Move(3, bool_is_occupied, u8_old_position);\n\n  game.array_players[1]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n\n  game.array_players[1]-&gt;Auto_Move(4, bool_is_occupied, u8_old_position);\n\n  game.array_players[1]-&gt;Auto_Move(2, bool_is_occupied, u8_old_position);\n\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 48);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 47);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(2) == 13);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(3) == 45);\n}\n</code></pre>"},{"location":"DeviceCode/002-TestCase__ComputerPlayer_8cpp/","title":"File 002-TestCase_ComputerPlayer.cpp","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; test &gt; 002-TestCase_ComputerPlayer.cpp</p> <p>Go to the source code of this file</p> <p>Test cases for the computer player. More...</p> <ul> <li><code>#include &lt;catch2/catch_test_macros.hpp&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;logic.hpp&gt;</code></li> </ul>"},{"location":"DeviceCode/002-TestCase__ComputerPlayer_8cpp/#public-functions","title":"Public Functions","text":"Type Name TEST_CASE ()  TEST_CASE (\"Test Professor V2\", \"\")  TEST_CASE (\"Test Auto_Move\", \"\")  TEST_CASE (\"Test Auto_Move into Finish while manual player is in finish\", \"\")  TEST_CASE (\"Test if player throws himself\", \"\")  TEST_CASE (\"Test if player throws himself in and before finish\", \"\")  TEST_CASE (\"Big test for professor mode\", \"\")"},{"location":"DeviceCode/002-TestCase__ComputerPlayer_8cpp/#detailed-description","title":"Detailed Description","text":"<p>This file contains multiple game situations for testing the behavior of the computer player. It covers various situations in which the computer player has to make decisions and move tokens with different start conditions. </p>"},{"location":"DeviceCode/002-TestCase__ComputerPlayer_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"DeviceCode/002-TestCase__ComputerPlayer_8cpp/#function-test_case","title":"function TEST_CASE","text":"<pre><code>TEST_CASE () \n</code></pre>"},{"location":"DeviceCode/002-TestCase__ComputerPlayer_8cpp/#function-test_case_1","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test Professor V2\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/002-TestCase__ComputerPlayer_8cpp/#function-test_case_2","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test Auto_Move\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/002-TestCase__ComputerPlayer_8cpp/#function-test_case_3","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test Auto_Move into Finish while manual player is in finish\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/002-TestCase__ComputerPlayer_8cpp/#function-test_case_4","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test if player throws himself\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/002-TestCase__ComputerPlayer_8cpp/#function-test_case_5","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test if player throws himself in and before finish\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/002-TestCase__ComputerPlayer_8cpp/#function-test_case_6","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Big test for professor mode\",\n    \"\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/test/002-TestCase_ComputerPlayer.cpp</code></p>"},{"location":"DeviceCode/002-TestCase__ComputerPlayer_8cpp_source/","title":"File 002-TestCase_ComputerPlayer.cpp","text":"<p>File List &gt; COD_ENG_OUT_arduino_code &gt; test &gt; 002-TestCase_ComputerPlayer.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;logic.hpp&gt;\n\n// Test hard compter player\nTEST_CASE(\"Test en_mode = Professor\", \"[cla_computer_player]\") {\n  LOGIC::cla_session game(2, 1, LOGIC::Professor);\n  bool bool_is_occupied;\n  uint8_t u8_old_position;\n\n  game.array_players[1]-&gt;Set_Token_Position(0, 25);\n  game.array_players[1]-&gt;Set_Token_Position(1, 35);\n  game.array_players[1]-&gt;Set_Token_Position(2, 16);\n  game.array_players[1]-&gt;Set_Token_Position(3, 15);\n  game.array_players[0]-&gt;Set_Token_Position(2, 36);\n  game.array_players[0]-&gt;Set_Token_Position(3, 37);\n  game.array_players[1]-&gt;Auto_Move(1, bool_is_occupied, u8_old_position);\n  game.array_players[1]-&gt;Auto_Move(1, bool_is_occupied, u8_old_position);\n  game.array_players[1]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n  game.array_players[1]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(3) == 4);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(2) == 3);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 31);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 43);\n}\n\n// Test hard compter player in more complex situation\nTEST_CASE(\"Test Professor V2\", \"[cla_computer_player]\") {\n  LOGIC::cla_session game(4, 2, LOGIC::Professor);\n  bool bool_is_occupied;\n  uint8_t u8_old_position;\n\n  game.array_players[0]-&gt;Set_Token_Position(3, 27);\n  game.array_players[0]-&gt;Set_Token_Position(0, 25);\n  game.array_players[2]-&gt;Set_Token_Position(3, 45);\n  REQUIRE(game.array_players[2]-&gt;Auto_Move(6, bool_is_occupied,\n                                           u8_old_position) == 0);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(0) == 25);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 1);\n  REQUIRE(game.array_players[2]-&gt;Auto_Move(6, bool_is_occupied,\n                                           u8_old_position) == 0);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(0) == 31);\n  game.array_players[1]-&gt;Set_Token_Position(2, 37);\n  REQUIRE(game.array_players[2]-&gt;Auto_Move(6, bool_is_occupied,\n                                           u8_old_position) == 1);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(0) == 31);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(1) == 25);\n  game.array_players[1]-&gt;Set_Token_Position(2, 33);\n  REQUIRE(game.array_players[2]-&gt;Auto_Move(2, bool_is_occupied,\n                                           u8_old_position) == 1);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(0) == 31);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(1) == 27);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(3) == 4);\n}\n\n// Test Auto_Move into finish\nTEST_CASE(\"Test Auto_Move\", \"[cla_player]\") {\n  LOGIC::cla_session game(2, 1, LOGIC::Student);\n  bool bool_is_occupied;\n  uint8_t u8_old_position;\n\n  game.array_players[0]-&gt;Set_Token_Position(0, 10);\n  game.array_players[1]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n  game.array_players[1]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 21);\n\n  game.array_players[1]-&gt;Set_Token_Position(0, 11);\n  game.array_players[1]-&gt;Set_Token_Position(1, 12);\n  game.array_players[1]-&gt;Set_Token_Position(2, 13);\n  game.array_players[1]-&gt;Set_Token_Position(3, 14);\n  REQUIRE(game.array_players[1]-&gt;Auto_Move(4, bool_is_occupied,\n                                           u8_old_position) == 0);\n  game.array_players[0]-&gt;Set_Token_Position(0, 48);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 45);\n  game.array_players[1]-&gt;Auto_Move(3, bool_is_occupied, u8_old_position);\n  game.array_players[1]-&gt;Auto_Move(5, bool_is_occupied, u8_old_position);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 47);\n  game.array_players[1]-&gt;Auto_Move(1, bool_is_occupied, u8_old_position);\n\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 48);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 47);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(2) == 13);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(3) == 45);\n}\n\n// One manual player is with 3 tokens in Finish, computer moves 4 token to\n// finish\nTEST_CASE(\"Test Auto_Move into Finish while manual player is in finish\",\n          \"[cla_player]\") {\n  LOGIC::cla_session game(2, 1, LOGIC::Student);\n  bool bool_is_occupied;\n  uint8_t u8_old_position;\n\n  game.array_players[0]-&gt;Set_Token_Position(0, 48);\n  game.array_players[0]-&gt;Set_Token_Position(1, 47);\n  game.array_players[0]-&gt;Set_Token_Position(2, 46);\n  game.array_players[0]-&gt;Set_Token_Position(3, 43);\n  game.array_players[1]-&gt;Set_Token_Position(0, 10);\n  game.array_players[1]-&gt;Set_Token_Position(1, 11);\n  game.array_players[1]-&gt;Set_Token_Position(2, 12);\n  game.array_players[1]-&gt;Set_Token_Position(3, 13);\n  game.array_players[1]-&gt;Auto_Move(5, bool_is_occupied, u8_old_position);\n  game.array_players[1]-&gt;Auto_Move(5, bool_is_occupied, u8_old_position);\n  game.array_players[1]-&gt;Auto_Move(5, bool_is_occupied, u8_old_position);\n  game.array_players[1]-&gt;Auto_Move(5, bool_is_occupied, u8_old_position);\n\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 45);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 46);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(2) == 47);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(3) == 48);\n\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 48);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 47);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(2) == 46);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(3) == 43);\n}\n\n// Test if player throws himself out of the game after start and on the field\nTEST_CASE(\"Test if player throws himself\", \"[cla_player]\") {\n  LOGIC::cla_session game(2, 1, LOGIC::Student);\n  bool bool_is_occupied;\n  uint8_t u8_old_position;\n\n  game.array_players[0]-&gt;Move_Token(0, 6);\n  game.array_players[0]-&gt;Move_Token(1, 6);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 5);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 2);\n  game.array_players[0]-&gt;Move_Token(0, 4);\n  game.array_players[0]-&gt;Move_Token(1, 6);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 9);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 5);\n  game.array_players[0]-&gt;Move_Token(1, 4);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 5);\n\n  game.array_players[1]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n  game.array_players[1]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 21);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 2);\n  game.array_players[1]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n  game.array_players[1]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 21);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 15);\n  game.array_players[1]-&gt;Auto_Move(4, bool_is_occupied, u8_old_position);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 19);\n}\n\n// Test if player throws himself out of the game in and before finish\nTEST_CASE(\"Test if player throws himself in and before finish\",\n          \"[cla_player]\") {\n  LOGIC::cla_session game(2, 1, LOGIC::Student);\n  bool bool_is_occupied;\n  uint8_t u8_old_position;\n\n  game.array_players[0]-&gt;Set_Token_Position(0, 46);\n  game.array_players[0]-&gt;Set_Token_Position(1, 44);\n  game.array_players[0]-&gt;Set_Token_Position(2, 43);\n  game.array_players[0]-&gt;Set_Token_Position(3, 45);\n  game.array_players[0]-&gt;Move_Token(2, 4);\n  game.array_players[0]-&gt;Move_Token(1, 3);\n  game.array_players[0]-&gt;Move_Token(0, 2);\n  game.array_players[0]-&gt;Move_Token(3, 3);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 48);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 44);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(2) == 47);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(3) == 45);\n\n  game.array_players[1]-&gt;Set_Token_Position(0, 46);\n  game.array_players[1]-&gt;Set_Token_Position(1, 14);\n  game.array_players[1]-&gt;Set_Token_Position(2, 13);\n  game.array_players[1]-&gt;Set_Token_Position(3, 45);\n\n  game.array_players[1]-&gt;Auto_Move(3, bool_is_occupied, u8_old_position);\n\n  game.array_players[1]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n\n  game.array_players[1]-&gt;Auto_Move(4, bool_is_occupied, u8_old_position);\n\n  game.array_players[1]-&gt;Auto_Move(2, bool_is_occupied, u8_old_position);\n\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 48);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 47);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(2) == 13);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(3) == 45);\n}\n\n// Test professor mode V2\nTEST_CASE(\"Big test for professor mode\", \"[cla_computer_player]\") {\n  LOGIC::cla_session game(4, 2, LOGIC::Professor);\n  bool bool_is_occupied;\n  uint8_t u8_old_position;\n\n  game.array_players[0]-&gt;Set_Token_Position(3, 29);\n  game.array_players[0]-&gt;Set_Token_Position(0, 28);\n  game.array_players[2]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(0) == 25);\n  game.array_players[2]-&gt;Auto_Move(2, bool_is_occupied, u8_old_position);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(0) == 27);\n  game.array_players[2]-&gt;Auto_Move(6, bool_is_occupied, u8_old_position);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(1) == 25);\n  game.array_players[2]-&gt;Auto_Move(3, bool_is_occupied, u8_old_position);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(1) == 28);\n  game.array_players[2]-&gt;Auto_Move(5, bool_is_occupied, u8_old_position);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(0) == 32);\n}\n</code></pre>"},{"location":"DeviceCode/003-TestCase__Session__and__Player_8cpp/","title":"File 003-TestCase_Session_and_Player.cpp","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; test &gt; 003-TestCase_Session_and_Player.cpp</p> <p>Go to the source code of this file</p> <p>Test cases for various situations during a game. More...</p> <ul> <li><code>#include &lt;catch2/catch_test_macros.hpp&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;logic.hpp&gt;</code></li> </ul>"},{"location":"DeviceCode/003-TestCase__Session__and__Player_8cpp/#public-functions","title":"Public Functions","text":"Type Name TEST_CASE (\"Test game constructer\", \"\")  TEST_CASE (\"Test Set_Token\", \"\")  TEST_CASE (\"Test Move_Token\", \"\")  TEST_CASE (\"Test Is_Startfield_occupied...\", \"\")  TEST_CASE (\"Test parallel Move into Finish\", \"\")  TEST_CASE (\"Test Get_Player_Progress V1\", \"\")"},{"location":"DeviceCode/003-TestCase__Session__and__Player_8cpp/#detailed-description","title":"Detailed Description","text":"<p>This file contains multiple game situations for testing the behavior of the game logic. It covers various situations in which the players have to make decisions and move tokens with different start conditions. </p>"},{"location":"DeviceCode/003-TestCase__Session__and__Player_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"DeviceCode/003-TestCase__Session__and__Player_8cpp/#function-test_case","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test game constructer\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/003-TestCase__Session__and__Player_8cpp/#function-test_case_1","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test Set_Token\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/003-TestCase__Session__and__Player_8cpp/#function-test_case_2","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test Move_Token \",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/003-TestCase__Session__and__Player_8cpp/#function-test_case_3","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test Is_Startfield_occupied...\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/003-TestCase__Session__and__Player_8cpp/#function-test_case_4","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test parallel Move into Finish\",\n    \"\"\n) \n</code></pre>"},{"location":"DeviceCode/003-TestCase__Session__and__Player_8cpp/#function-test_case_5","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test Get_Player_Progress V1\",\n    \"\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/test/003-TestCase_Session_and_Player.cpp</code></p>"},{"location":"DeviceCode/003-TestCase__Session__and__Player_8cpp_source/","title":"File 003-TestCase_Session_and_Player.cpp","text":"<p>File List &gt; COD_ENG_OUT_arduino_code &gt; test &gt; 003-TestCase_Session_and_Player.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;logic.hpp&gt;\n\nTEST_CASE(\"Test game constructer\", \"[cla_session]\") {\n  LOGIC::cla_session game(4, 1, LOGIC::Student);\n  REQUIRE(game.Get_Player_Quantity() == 4);\n  REQUIRE(game.Get_Computer_Quantity() == 1);\n}\n\nTEST_CASE(\"Test Set_Token\", \"[cla_player]\") {\n  LOGIC::cla_session game(4, 2, LOGIC::Student);\n  game.array_players[0]-&gt;Set_Token_Position(0, 45);\n  game.array_players[1]-&gt;Set_Token_Position(1, 25);\n  game.array_players[2]-&gt;Set_Token_Position(2, 29);\n  game.array_players[3]-&gt;Set_Token_Position(3, 30);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 45);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 25);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(2) == 29);\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(3) == 30);\n}\n\nTEST_CASE(\"Test Move_Token\", \"[cla_player]\") {\n  LOGIC::cla_session game(4, 0, LOGIC::Student);\n  game.array_players[0]-&gt;Set_Token_Position(0, 45);\n  game.array_players[0]-&gt;Set_Token_Position(1, 25);\n  game.array_players[0]-&gt;Set_Token_Position(2, 29);\n  game.array_players[0]-&gt;Set_Token_Position(3, 30);\n  game.array_players[0]-&gt;Move_Token(0, 4);\n  game.array_players[0]-&gt;Move_Token(1, 3);\n  game.array_players[0]-&gt;Move_Token(2, 2);\n  game.array_players[0]-&gt;Move_Token(3, 1);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 45);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 28);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(2) == 31);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(3) == 30);\n}\n\nTEST_CASE(\"Test Is_Startfield_occupied...\", \"[cla_player]\") {\n  LOGIC::cla_session game(4, 0, LOGIC::Student);\n  game.array_players[0]-&gt;Set_Token_Position(0, 5);\n  game.array_players[1]-&gt;Set_Token_Position(1, 15);\n  game.array_players[2]-&gt;Set_Token_Position(2, 25);\n  game.array_players[3]-&gt;Set_Token_Position(3, 35);\n  REQUIRE(game.array_players[0]-&gt;Is_Start_Field_Occupied_By_Own_Token() == 0);\n  REQUIRE(game.array_players[1]-&gt;Is_Start_Field_Occupied_By_Own_Token() == 1);\n  REQUIRE(game.array_players[2]-&gt;Is_Start_Field_Occupied_By_Own_Token() == 2);\n  REQUIRE(game.array_players[3]-&gt;Is_Start_Field_Occupied_By_Own_Token() == 3);\n  game.array_players[0]-&gt;Set_Token_Position(3, 8);\n  game.array_players[0]-&gt;Set_Token_Position(1, 6);\n  game.array_players[0]-&gt;Set_Token_Position(2, 7);\n  REQUIRE(game.array_players[0]-&gt;Is_Start_Field_Occupied_By_Own_Token() == -1);\n}\n\n// Test all players move into finish:\nTEST_CASE(\"Test parallel Move into Finish\", \"[cla_player]\") {\n  LOGIC::cla_session game(4, 0, LOGIC::Student);\n\n  // Player 0\n  game.array_players[0]-&gt;Set_Token_Position(0, 40);\n  game.array_players[0]-&gt;Set_Token_Position(1, 41);\n  game.array_players[0]-&gt;Set_Token_Position(2, 42);\n  game.array_players[0]-&gt;Set_Token_Position(3, 43);\n  game.array_players[0]-&gt;Move_Token(0, 5);\n  game.array_players[0]-&gt;Move_Token(1, 5);\n  game.array_players[0]-&gt;Move_Token(2, 5);\n  game.array_players[0]-&gt;Move_Token(3, 5);\n\n  // Player 1\n  game.array_players[1]-&gt;Set_Token_Position(0, 10);\n  game.array_players[1]-&gt;Set_Token_Position(1, 11);\n  game.array_players[1]-&gt;Set_Token_Position(2, 12);\n  game.array_players[1]-&gt;Set_Token_Position(3, 13);\n  game.array_players[1]-&gt;Move_Token(0, 6);\n  game.array_players[1]-&gt;Move_Token(1, 6);\n  game.array_players[1]-&gt;Move_Token(2, 3);\n  game.array_players[1]-&gt;Move_Token(3, 5);\n\n  // Player 2\n  game.array_players[2]-&gt;Set_Token_Position(0, 24);\n  game.array_players[2]-&gt;Set_Token_Position(1, 21);\n  game.array_players[2]-&gt;Set_Token_Position(2, 22);\n  game.array_players[2]-&gt;Set_Token_Position(3, 23);\n  game.array_players[2]-&gt;Move_Token(0, 4);\n  game.array_players[2]-&gt;Move_Token(1, 6);\n  game.array_players[2]-&gt;Move_Token(2, 4);\n  game.array_players[2]-&gt;Move_Token(3, 2);\n\n  // Player 3\n  game.array_players[3]-&gt;Set_Token_Position(0, 33);\n  game.array_players[3]-&gt;Set_Token_Position(1, 31);\n  game.array_players[3]-&gt;Set_Token_Position(2, 32);\n  game.array_players[3]-&gt;Set_Token_Position(3, 34);\n  game.array_players[3]-&gt;Move_Token(0, 2);\n  game.array_players[3]-&gt;Move_Token(1, 6);\n  game.array_players[3]-&gt;Move_Token(2, 6);\n  game.array_players[3]-&gt;Move_Token(3, 2);\n\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(0) == 45);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(1) == 46);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(2) == 47);\n  REQUIRE(game.array_players[0]-&gt;Get_Token_Position(3) == 48);\n\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(0) == 46);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(1) == 47);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(2) == 45);\n  REQUIRE(game.array_players[1]-&gt;Get_Token_Position(3) == 48);\n\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(0) == 48);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(1) == 47);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(2) == 46);\n  REQUIRE(game.array_players[2]-&gt;Get_Token_Position(3) == 45);\n\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(0) == 45);\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(1) == 47);\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(2) == 48);\n  REQUIRE(game.array_players[3]-&gt;Get_Token_Position(3) == 46);\n}\n\n// Test Get_Player_Progress\nTEST_CASE(\"Test Get_Player_Progress V1\", \"[cla_player]\") {\n  LOGIC::cla_session game(4, 4, LOGIC::Student);\n  game.array_players[0]-&gt;Set_Token_Position(0, 45);\n  game.array_players[0]-&gt;Set_Token_Position(1, 43);\n  game.array_players[0]-&gt;Set_Token_Position(2, 46);\n  game.array_players[0]-&gt;Set_Token_Position(3, 47);\n  REQUIRE(game.array_players[0]-&gt;Get_Player_Progress() == 27);\n\n  game.array_players[1]-&gt;Set_Token_Position(0, 1);\n  game.array_players[1]-&gt;Set_Token_Position(1, 2);\n  game.array_players[1]-&gt;Set_Token_Position(2, 3);\n  game.array_players[1]-&gt;Set_Token_Position(3, 4);\n  REQUIRE(game.array_players[1]-&gt;Get_Player_Progress() == 1);\n\n  game.array_players[2]-&gt;Set_Token_Position(0, 45);\n  game.array_players[2]-&gt;Set_Token_Position(1, 24);\n  game.array_players[2]-&gt;Set_Token_Position(2, 46);\n  game.array_players[2]-&gt;Set_Token_Position(3, 47);\n  REQUIRE(game.array_players[2]-&gt;Get_Player_Progress() == 27);\n\n  game.array_players[3]-&gt;Set_Token_Position(0, 1);\n  game.array_players[3]-&gt;Set_Token_Position(1, 2);\n  game.array_players[3]-&gt;Set_Token_Position(2, 3);\n  game.array_players[3]-&gt;Set_Token_Position(3, 4);\n  REQUIRE(game.array_players[3]-&gt;Get_Player_Progress() == 1);\n\n  game.array_players[0]-&gt;Set_Token_Position(0, 20);\n  game.array_players[0]-&gt;Set_Token_Position(1, 21);\n  game.array_players[0]-&gt;Set_Token_Position(2, 22);\n  game.array_players[0]-&gt;Set_Token_Position(3, 23);\n  REQUIRE(game.array_players[0]-&gt;Get_Player_Progress() == 12);\n\n  game.array_players[0]-&gt;Set_Token_Position(0, 45);\n  game.array_players[0]-&gt;Set_Token_Position(1, 46);\n  game.array_players[0]-&gt;Set_Token_Position(2, 47);\n  game.array_players[0]-&gt;Set_Token_Position(3, 48);\n  REQUIRE(game.array_players[0]-&gt;Get_Player_Progress() == 28);\n}\n</code></pre>"},{"location":"DeviceCode/marked__dice_8hpp/","title":"File marked_dice.hpp","text":"<p>FileList &gt; COD_ENG_OUT_arduino_code &gt; test &gt; marked_dice.hpp</p> <p>Go to the source code of this file</p> <p>This file contains the dice values for the test cases. More...</p> <ul> <li><code>#include \"Arduino.h\"</code></li> </ul>"},{"location":"DeviceCode/marked__dice_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name const uint8_t u8_dice_value_array   = = {6, 40, 6, 41, 6, 42, 6, 43, 1, 1,  1, 1,  1, 1,  1}"},{"location":"DeviceCode/marked__dice_8hpp/#macros","title":"Macros","text":"Type Name define TEST_CASE  2"},{"location":"DeviceCode/marked__dice_8hpp/#detailed-description","title":"Detailed Description","text":"<p>This file contains multiple arrays for different test cases. The array to be used can be selected using the TEST_CASE macro. </p>"},{"location":"DeviceCode/marked__dice_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"DeviceCode/marked__dice_8hpp/#variable-u8_dice_value_array","title":"variable u8_dice_value_array","text":"<pre><code>const uint8_t u8_dice_value_array[];\n</code></pre>"},{"location":"DeviceCode/marked__dice_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"DeviceCode/marked__dice_8hpp/#define-test_case","title":"define TEST_CASE","text":"<pre><code>#define TEST_CASE 2\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_arduino_code/test/marked_dice.hpp</code></p>"},{"location":"DeviceCode/marked__dice_8hpp_source/","title":"File marked_dice.hpp","text":"<p>File List &gt; COD_ENG_OUT_arduino_code &gt; test &gt; marked_dice.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef MARKED_DICE_HPP\n#define MARKED_DICE_HPP\n#include \"Arduino.h\"\n\n#define TEST_CASE 2\n\n#if TEST_CASE == 0\n// Test the Dice roll counter (you can roll the dice 3 times when all tokens in\n// starting square, if the dice value is 6, you get a second turn.)\n// 1 Real Player, 1 Computer Player\nconst uint8_t u8_dice_value_array[] = {6, 6, 5, 1, 1, 6, 2,\n                                       1, 1, 1, 1, 1, 6, 3};\n#elif TEST_CASE == 1\n// Test token blinking\n// 1 Real Player, 1 Computer Player\nconst uint8_t u8_dice_value_array[] = {6, 5, 6, 1, 6, 4, 1, 4, 1, 4, 1, 1, 1};\n#elif TEST_CASE == 2\n// Test winner animation (Get Player 1 in finishing square as fast as possible)\n// 1 Real Player\nconst uint8_t u8_dice_value_array[] = {6, 40, 6, 41, 6, 42, 6, 43,\n                                       1, 1,  1, 1,  1, 1,  1};\n#elif TEST_CASE == 3\n// Test walking (test if tokens walk over each other)\n// 2 Real Players\nconst uint8_t u8_dice_value_array[] = {6, 5, 6, 1, 5, 1, 3, 3,\n                                       4, 4, 5, 4, 2, 5, 4};\n#elif TEST_CASE == 4\n// Test walking (test if tokens can get accross 44/5 line without problems)\n// 4 Real Players\nconst uint8_t u8_dice_value_array[] = {6, 5, 1, 1, 1, 1, 1, 1, 6, 5,\n                                       6, 1, 1, 1, 1, 1, 1, 1, 7};\n#elif TEST_CASE == 5\n// Test walking: New player dissapears\n// Expected behavior: Player 1 should dissapear from the track, because he is\n// thrown by player 2 2 Real Players\nconst uint8_t u8_dice_value_array[] = {6, 15, 6, 5, 0, 0, 0, 0};\n#elif TEST_CASE == 6\n// Test walking: New player dissapears\n// Expected behavior: Player 1 should dissapear from the track, because he is\n// thrown by player 2\n// 2 Real Players\nconst uint8_t u8_dice_value_array[] = {6, 5, 1, 1, 1, 5, 1, 1,\n                                       1, 3, 6, 1, 1, 3, 0, 0};\n#elif TEST_CASE == 7\n// Test walking: Player on position 44\n// Expected behavior: Green player should be on position 44.\n// 4 real players\nconst uint8_t u8_dice_value_array[] = {6, 1, 6, 1, 6, 1, 6, 9, 1, 1, 1, 1};\n#elif TEST_CASE == 8\n// Test walking: finish line\n// Expected behavior: Players should finish\n// 4 real players\nconst uint8_t u8_dice_value_array[] = {6, 39, 6, 39, 6, 39, 6, 39, 1, 1,\n                                       1, 1,  6, 41, 6, 42, 6, 43, 6, 41};\n#elif TEST_CASE == 9\n// Test walking: finish line\n// Expected behavior: Player1 should finish\n// 1 real player\nconst uint8_t u8_dice_value_array[] = {6, 39, 1, 6, 38, 3, 6, 42, 6, 43};\n// BUG-SPECIFIC TEST CASES\n#elif TEST_CASE == 10\n// Test Bug: Player 1 throw player 3\n// Expected behavior: Player 3 should be thrown and immediatly appear in his\n// starting square 3 real players\nconst uint8_t u8_dice_value_array[] = {6, 21, 6, 1, 6, 3, 2};\n#elif TEST_CASE == 11\n// Test Bug: Player 1 blink in finish position [seems like bug appears if finish\n// position is occupied by other player]\n// Expected behavior: Player 1 should\n// blink in his finish position 2 real player\nconst uint8_t u8_dice_value_array[] = {6, 40, 6, 41, 6, 1, 0, 1};\n#endif\n\n#endif\n</code></pre>"},{"location":"DeviceCode/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace ASL </li> <li>namespace LOGIC </li> </ul>"},{"location":"DeviceCode/classes/","title":"Class Index","text":""},{"location":"DeviceCode/classes/#c","title":"c","text":"<ul> <li>cla_computer_player (LOGIC)</li> <li>cla_display (ASL)</li> <li>cla_manual_player (LOGIC)</li> <li>cla_player (LOGIC)</li> <li>cla_session (LOGIC)</li> </ul>"},{"location":"DeviceCode/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class ASL::cla_display display handler </li> <li>class LOGIC::cla_player This class represents a player in the game. It provides methods for moving tokens and checking the status of the player. It is an abstract class and has two derived classes: cla_computer_player andcla_manual_player . <ul> <li>class LOGIC::cla_computer_player This class represents a computer opponent in the game. It provides methods for automatic movement of tokens. It is derived from the cla_player .</li> <li>class LOGIC::cla_manual_player This class represents a manual player in a game. It is derived from the cla_player class.</li> </ul> </li> <li>class LOGIC::cla_session The cla_session class is the main class of the game logic. It initializes the players with their methods and it provides essential methods for the game logic.</li> </ul>"},{"location":"DeviceCode/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"DeviceCode/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"DeviceCode/class_members/","title":"Class Members","text":""},{"location":"DeviceCode/class_members/#a","title":"a","text":"<ul> <li>Auto_Move (LOGIC::cla_computer_player, LOGIC::cla_player)</li> <li>array_players (LOGIC::cla_session)</li> </ul>"},{"location":"DeviceCode/class_members/#b","title":"b","text":"<ul> <li>Begin (ASL::cla_display)</li> <li>Blink_Is_On (ASL::cla_display)</li> <li>Blink_Start (ASL::cla_display)</li> <li>Blink_Stop (ASL::cla_display)</li> <li>Blink_Update (ASL::cla_display)</li> </ul>"},{"location":"DeviceCode/class_members/#c","title":"c","text":"<ul> <li>cla_display (ASL::cla_display)</li> <li>cla_computer_player (LOGIC::cla_computer_player)</li> <li>cla_manual_player (LOGIC::cla_manual_player)</li> <li>Calculate_Possible_Position (LOGIC::cla_player)</li> <li>cla_player (LOGIC::cla_player)</li> <li>cla_session (LOGIC::cla_session)</li> </ul>"},{"location":"DeviceCode/class_members/#d","title":"d","text":"<ul> <li>Display_Char (ASL::cla_display)</li> <li>Display_Clear_Right (ASL::cla_display)</li> <li>Display_Current_Player (ASL::cla_display)</li> <li>Display_Dice (ASL::cla_display)</li> <li>Display_Players (ASL::cla_display)</li> <li>Display_Progress (ASL::cla_display)</li> <li>Display_Restore (ASL::cla_display)</li> <li>Display_Track (ASL::cla_display)</li> </ul>"},{"location":"DeviceCode/class_members/#e","title":"e","text":"<ul> <li>en_current_blink_mode (ASL::cla_display)</li> <li>en_current_blink_type (ASL::cla_display)</li> <li>en_mode (LOGIC::cla_computer_player)</li> </ul>"},{"location":"DeviceCode/class_members/#g","title":"g","text":"<ul> <li>Get_Player_Progress (LOGIC::cla_player)</li> <li>Get_Player_Status (LOGIC::cla_player)</li> <li>Get_Start_Position (LOGIC::cla_player)</li> <li>Get_Token_Position (LOGIC::cla_player)</li> <li>Get_Token_Progress (LOGIC::cla_player)</li> <li>Get_Computer_Quantity (LOGIC::cla_session)</li> <li>Get_Player_Quantity (LOGIC::cla_session)</li> </ul>"},{"location":"DeviceCode/class_members/#i","title":"i","text":"<ul> <li>i8_blink_counter (ASL::cla_display)</li> <li>i8_blink_second_player (ASL::cla_display)</li> <li>Is_Computer (LOGIC::cla_computer_player, LOGIC::cla_manual_player, LOGIC::cla_player)</li> <li>Is_Start_Field_Occupied_By_Own_Token (LOGIC::cla_player)</li> <li>Is_Occupied (LOGIC::cla_session)</li> </ul>"},{"location":"DeviceCode/class_members/#m","title":"m","text":"<ul> <li>Modify_Position (ASL::cla_display)</li> <li>Move_Token (ASL::cla_display, LOGIC::cla_player)</li> </ul>"},{"location":"DeviceCode/class_members/#o","title":"o","text":"<ul> <li>obj_matrix (ASL::cla_display)</li> <li>obj_my_session (LOGIC::cla_player)</li> </ul>"},{"location":"DeviceCode/class_members/#r","title":"r","text":"<ul> <li>Return_Home (LOGIC::cla_session)</li> </ul>"},{"location":"DeviceCode/class_members/#s","title":"s","text":"<ul> <li>Set_Colors (ASL::cla_display)</li> <li>Set_Token_Position (LOGIC::cla_player)</li> </ul>"},{"location":"DeviceCode/class_members/#u","title":"u","text":"<ul> <li>u16_player_color (ASL::cla_display)</li> <li>u16_track_color (ASL::cla_display)</li> <li>u8_blink_new_position (ASL::cla_display)</li> <li>u8_blink_old_position (ASL::cla_display)</li> <li>u8_blink_player_number (ASL::cla_display)</li> <li>u8_blink_state (ASL::cla_display)</li> <li>u8_finish_positions (ASL::cla_display)</li> <li>u8_home_positions (ASL::cla_display)</li> <li>u8_matrix_a (ASL::cla_display)</li> <li>u8_matrix_b (ASL::cla_display)</li> <li>u8_matrix_c (ASL::cla_display)</li> <li>u8_matrix_clk (ASL::cla_display)</li> <li>u8_matrix_lat (ASL::cla_display)</li> <li>u8_matrix_oe (ASL::cla_display)</li> <li>u8_smiley_postitions (ASL::cla_display)</li> <li>u8_track_positions (ASL::cla_display)</li> <li>u8_player_id (LOGIC::cla_player)</li> <li>u8_start_position (LOGIC::cla_player)</li> <li>u8_token_position (LOGIC::cla_player)</li> <li>u8_computer_quantity (LOGIC::cla_session)</li> <li>u8_is_occupied_player_id (LOGIC::cla_session)</li> <li>u8_is_occupied_token_number (LOGIC::cla_session)</li> <li>u8_player_quantity (LOGIC::cla_session)</li> </ul>"},{"location":"DeviceCode/class_member_functions/","title":"Class Member Functions","text":""},{"location":"DeviceCode/class_member_functions/#a","title":"a","text":"<ul> <li>Auto_Move (LOGIC::cla_computer_player, LOGIC::cla_player)</li> </ul>"},{"location":"DeviceCode/class_member_functions/#b","title":"b","text":"<ul> <li>Begin (ASL::cla_display)</li> <li>Blink_Is_On (ASL::cla_display)</li> <li>Blink_Start (ASL::cla_display)</li> <li>Blink_Stop (ASL::cla_display)</li> <li>Blink_Update (ASL::cla_display)</li> </ul>"},{"location":"DeviceCode/class_member_functions/#c","title":"c","text":"<ul> <li>cla_display (ASL::cla_display)</li> <li>cla_computer_player (LOGIC::cla_computer_player)</li> <li>cla_manual_player (LOGIC::cla_manual_player)</li> <li>Calculate_Possible_Position (LOGIC::cla_player)</li> <li>cla_player (LOGIC::cla_player)</li> <li>cla_session (LOGIC::cla_session)</li> </ul>"},{"location":"DeviceCode/class_member_functions/#d","title":"d","text":"<ul> <li>Display_Char (ASL::cla_display)</li> <li>Display_Clear_Right (ASL::cla_display)</li> <li>Display_Current_Player (ASL::cla_display)</li> <li>Display_Dice (ASL::cla_display)</li> <li>Display_Players (ASL::cla_display)</li> <li>Display_Progress (ASL::cla_display)</li> <li>Display_Restore (ASL::cla_display)</li> <li>Display_Track (ASL::cla_display)</li> </ul>"},{"location":"DeviceCode/class_member_functions/#g","title":"g","text":"<ul> <li>Get_Player_Progress (LOGIC::cla_player)</li> <li>Get_Player_Status (LOGIC::cla_player)</li> <li>Get_Start_Position (LOGIC::cla_player)</li> <li>Get_Token_Position (LOGIC::cla_player)</li> <li>Get_Token_Progress (LOGIC::cla_player)</li> <li>Get_Computer_Quantity (LOGIC::cla_session)</li> <li>Get_Player_Quantity (LOGIC::cla_session)</li> </ul>"},{"location":"DeviceCode/class_member_functions/#i","title":"i","text":"<ul> <li>Is_Computer (LOGIC::cla_computer_player, LOGIC::cla_manual_player, LOGIC::cla_player)</li> <li>Is_Start_Field_Occupied_By_Own_Token (LOGIC::cla_player)</li> <li>Is_Occupied (LOGIC::cla_session)</li> </ul>"},{"location":"DeviceCode/class_member_functions/#m","title":"m","text":"<ul> <li>Modify_Position (ASL::cla_display)</li> <li>Move_Token (ASL::cla_display, LOGIC::cla_player)</li> </ul>"},{"location":"DeviceCode/class_member_functions/#r","title":"r","text":"<ul> <li>Return_Home (LOGIC::cla_session)</li> </ul>"},{"location":"DeviceCode/class_member_functions/#s","title":"s","text":"<ul> <li>Set_Colors (ASL::cla_display)</li> <li>Set_Token_Position (LOGIC::cla_player)</li> </ul>"},{"location":"DeviceCode/class_member_variables/","title":"Class Member Variables","text":""},{"location":"DeviceCode/class_member_variables/#a","title":"a","text":"<ul> <li>array_players (LOGIC::cla_session)</li> </ul>"},{"location":"DeviceCode/class_member_variables/#e","title":"e","text":"<ul> <li>en_current_blink_mode (ASL::cla_display)</li> <li>en_current_blink_type (ASL::cla_display)</li> <li>en_mode (LOGIC::cla_computer_player)</li> </ul>"},{"location":"DeviceCode/class_member_variables/#i","title":"i","text":"<ul> <li>i8_blink_counter (ASL::cla_display)</li> <li>i8_blink_second_player (ASL::cla_display)</li> </ul>"},{"location":"DeviceCode/class_member_variables/#o","title":"o","text":"<ul> <li>obj_matrix (ASL::cla_display)</li> <li>obj_my_session (LOGIC::cla_player)</li> </ul>"},{"location":"DeviceCode/class_member_variables/#u","title":"u","text":"<ul> <li>u16_player_color (ASL::cla_display)</li> <li>u16_track_color (ASL::cla_display)</li> <li>u8_blink_new_position (ASL::cla_display)</li> <li>u8_blink_old_position (ASL::cla_display)</li> <li>u8_blink_player_number (ASL::cla_display)</li> <li>u8_blink_state (ASL::cla_display)</li> <li>u8_finish_positions (ASL::cla_display)</li> <li>u8_home_positions (ASL::cla_display)</li> <li>u8_matrix_a (ASL::cla_display)</li> <li>u8_matrix_b (ASL::cla_display)</li> <li>u8_matrix_c (ASL::cla_display)</li> <li>u8_matrix_clk (ASL::cla_display)</li> <li>u8_matrix_lat (ASL::cla_display)</li> <li>u8_matrix_oe (ASL::cla_display)</li> <li>u8_smiley_postitions (ASL::cla_display)</li> <li>u8_track_positions (ASL::cla_display)</li> <li>u8_player_id (LOGIC::cla_player)</li> <li>u8_start_position (LOGIC::cla_player)</li> <li>u8_token_position (LOGIC::cla_player)</li> <li>u8_computer_quantity (LOGIC::cla_session)</li> <li>u8_is_occupied_player_id (LOGIC::cla_session)</li> <li>u8_is_occupied_token_number (LOGIC::cla_session)</li> <li>u8_player_quantity (LOGIC::cla_session)</li> </ul>"},{"location":"DeviceCode/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"DeviceCode/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"DeviceCode/namespace_members/","title":"Namespace Members","text":""},{"location":"DeviceCode/namespace_members/#d","title":"d","text":"<ul> <li>Delay_256 (ASL)</li> </ul>"},{"location":"DeviceCode/namespace_members/#e","title":"e","text":"<ul> <li>en_blink_mode (ASL)</li> <li>en_blink_type (ASL)</li> <li>en_state (ASL)</li> </ul>"},{"location":"DeviceCode/namespace_members/#m","title":"m","text":"<ul> <li>mode (LOGIC)</li> </ul>"},{"location":"DeviceCode/namespace_members/#r","title":"r","text":"<ul> <li>Roll_Dice (ASL)</li> </ul>"},{"location":"DeviceCode/namespace_members/#s","title":"s","text":"<ul> <li>Setup_Buttons (ASL)</li> <li>Setup_Dice (ASL)</li> <li>status (LOGIC)</li> </ul>"},{"location":"DeviceCode/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"DeviceCode/namespace_member_functions/#d","title":"d","text":"<ul> <li>Delay_256 (ASL)</li> </ul>"},{"location":"DeviceCode/namespace_member_functions/#r","title":"r","text":"<ul> <li>Roll_Dice (ASL)</li> </ul>"},{"location":"DeviceCode/namespace_member_functions/#s","title":"s","text":"<ul> <li>Setup_Buttons (ASL)</li> <li>Setup_Dice (ASL)</li> </ul>"},{"location":"DeviceCode/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"DeviceCode/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"DeviceCode/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"DeviceCode/namespace_member_enums/#e","title":"e","text":"<ul> <li>en_blink_mode (ASL)</li> <li>en_blink_type (ASL)</li> <li>en_state (ASL)</li> </ul>"},{"location":"DeviceCode/namespace_member_enums/#m","title":"m","text":"<ul> <li>mode (LOGIC)</li> </ul>"},{"location":"DeviceCode/namespace_member_enums/#s","title":"s","text":"<ul> <li>status (LOGIC)</li> </ul>"},{"location":"DeviceCode/functions/","title":"Functions","text":""},{"location":"DeviceCode/functions/#i","title":"i","text":"<ul> <li>ISR (interupt.cpp)</li> </ul>"},{"location":"DeviceCode/functions/#l","title":"l","text":"<ul> <li>loop (main.cpp)</li> </ul>"},{"location":"DeviceCode/functions/#m","title":"m","text":"<ul> <li>Move_Token (animations.cpp, main.cpp)</li> </ul>"},{"location":"DeviceCode/functions/#s","title":"s","text":"<ul> <li>setup (main.cpp)</li> </ul>"},{"location":"DeviceCode/functions/#t","title":"t","text":"<ul> <li>TEST_CASE (001-TestCase_Requirements.cpp, 002-TestCase_ComputerPlayer.cpp, 003-TestCase_Session_and_Player.cpp)</li> </ul>"},{"location":"DeviceCode/macros/","title":"Macros","text":""},{"location":"DeviceCode/macros/#a","title":"a","text":"<ul> <li>A (defines.hpp)</li> <li>ANIMATION_SPEED_COMPUTER (defines.hpp)</li> <li>ANIMATION_SPEED_DICE (defines.hpp)</li> <li>ANIMATION_SPEED_MOVE (defines.hpp)</li> <li>ANIMATIONS (animations.cpp)</li> </ul>"},{"location":"DeviceCode/macros/#b","title":"b","text":"<ul> <li>B (defines.hpp)</li> <li>BLINK_CYCLES_OCCUPIED_TOKEN (defines.hpp)</li> <li>BLINK_CYCLES_TOKEN (defines.hpp)</li> <li>BLINK_CYCLES_WINNER_ANIMATION (defines.hpp)</li> <li>BLUE_BRIGHT (defines.hpp)</li> <li>BLUE_DARK (defines.hpp)</li> </ul>"},{"location":"DeviceCode/macros/#c","title":"c","text":"<ul> <li>C (defines.hpp)</li> <li>CLK (defines.hpp)</li> </ul>"},{"location":"DeviceCode/macros/#d","title":"d","text":"<ul> <li>DEBOUNCE_TIME (defines.hpp)</li> <li>DEBUG (defines.hpp)</li> <li>DICE_MODE (defines.hpp)</li> <li>DICE_ROLLS_AT_SIX (defines.hpp)</li> <li>DICE_ROLLS_AT_START (defines.hpp)</li> <li>DICE_ROLLS_NORMAL (defines.hpp)</li> </ul>"},{"location":"DeviceCode/macros/#f","title":"f","text":"<ul> <li>FAST_BLINK (defines.hpp)</li> </ul>"},{"location":"DeviceCode/macros/#g","title":"g","text":"<ul> <li>GREEN_BRIGHT (defines.hpp)</li> <li>GREEN_DARK (defines.hpp)</li> </ul>"},{"location":"DeviceCode/macros/#i","title":"i","text":"<ul> <li>INITIAL_BOOL_BLINK_FLAG (defines.hpp)</li> <li>INITIAL_COMPUTER_MODE (defines.hpp)</li> <li>INITIAL_COMPUTER_QUANTITY (defines.hpp)</li> <li>INITIAL_CURRENT_PLAYER_NUMBER (defines.hpp)</li> <li>INITIAL_CURRENT_TOKEN_NUMBER (defines.hpp)</li> <li>INITIAL_DICE_ROLL_COUNTER (defines.hpp)</li> <li>INITIAL_DICE_VALUE (defines.hpp)</li> <li>INITIAL_PLAYER_QUANTITY (defines.hpp)</li> </ul>"},{"location":"DeviceCode/macros/#l","title":"l","text":"<ul> <li>LAT (defines.hpp)</li> </ul>"},{"location":"DeviceCode/macros/#o","title":"o","text":"<ul> <li>OE (defines.hpp)</li> </ul>"},{"location":"DeviceCode/macros/#r","title":"r","text":"<ul> <li>RED_BRIGHT (defines.hpp)</li> <li>RED_DARK (defines.hpp)</li> </ul>"},{"location":"DeviceCode/macros/#s","title":"s","text":"<ul> <li>SLOW_BLINK (defines.hpp)</li> </ul>"},{"location":"DeviceCode/macros/#t","title":"t","text":"<ul> <li>TIMING_DEBUG (defines.hpp)</li> <li>TIMING_DEBUG_COUNT_TO (defines.hpp)</li> <li>TIMING_DEBUG_INTERN (defines.hpp)</li> <li>TEST_CASE (marked_dice.hpp)</li> </ul>"},{"location":"DeviceCode/macros/#w","title":"w","text":"<ul> <li>WHITE_BRIGHT (defines.hpp)</li> </ul>"},{"location":"DeviceCode/macros/#y","title":"y","text":"<ul> <li>YELLOW_BRIGHT (defines.hpp)</li> <li>YELLOW_DARK (defines.hpp)</li> </ul>"},{"location":"DeviceCode/variables/","title":"Variables","text":""},{"location":"DeviceCode/variables/#b","title":"b","text":"<ul> <li>bool_blink_flag (interupt.cpp, main.cpp)</li> </ul>"},{"location":"DeviceCode/variables/#e","title":"e","text":"<ul> <li>en_current_state (interupt.cpp, main.cpp)</li> </ul>"},{"location":"DeviceCode/variables/#i","title":"i","text":"<ul> <li>i8_current_token_number (interupt.cpp, main.cpp)</li> <li>i8_current_player_number (main.cpp)</li> </ul>"},{"location":"DeviceCode/variables/#o","title":"o","text":"<ul> <li>obj_display (interupt.cpp, main.cpp)</li> <li>obj_session (main.cpp)</li> </ul>"},{"location":"DeviceCode/variables/#u","title":"u","text":"<ul> <li>u8_computer_quantity (interupt.cpp, main.cpp)</li> <li>u8_player_quantity (interupt.cpp, main.cpp)</li> <li>u8_dice_value_array (marked_dice.hpp)</li> </ul>"},{"location":"DeviceCode/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"TestCode/annotated/","title":"Class List","text":"<p>No classes, structs, unions or interfaces found.</p>"},{"location":"TestCode/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir Engineering <ul> <li>dir COD_ENG_OUT_Pruefgeraet <ul> <li>dir src <ul> <li>file main.cpp </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"TestCode/dir_6774b76becf5c1eba00b38f86dafd5a0/","title":"Dir Engineering","text":"<p>FileList &gt; Engineering</p>"},{"location":"TestCode/dir_6774b76becf5c1eba00b38f86dafd5a0/#directories","title":"Directories","text":"Type Name dir COD_ENG_OUT_Pruefgeraet <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/</code></p>"},{"location":"TestCode/dir_a5ee031e87d12abe48a2fc4670eea239/","title":"Dir COD_ENG_OUT_Pruefgeraet","text":"<p>FileList &gt; COD_ENG_OUT_Pruefgeraet</p>"},{"location":"TestCode/dir_a5ee031e87d12abe48a2fc4670eea239/#directories","title":"Directories","text":"Type Name dir src <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_Pruefgeraet/</code></p>"},{"location":"TestCode/dir_6fb120e1e93f6ff794cb9ba09d32e262/","title":"Dir src","text":"<p>FileList &gt; COD_ENG_OUT_Pruefgeraet &gt; src</p>"},{"location":"TestCode/dir_6fb120e1e93f6ff794cb9ba09d32e262/#files","title":"Files","text":"Type Name file main.cpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_Pruefgeraet/src/</code></p>"},{"location":"TestCode/main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; COD_ENG_OUT_Pruefgeraet &gt; src &gt; main.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"TestCode/main_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name float fl_high_frequency   = = 0.0 float fl_low_frequency   = = 0.0 const int i_pin   = = 2 uint32_t u32_duration_high   = = 0 uint32_t u32_duration_low   = = 0 uint32_t u32_start_time_high   = = 0 uint32_t u32_start_time_low   = = 0"},{"location":"TestCode/main_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Pin_Change () This function is responsible for handling pin state changes. void loop ()  void setup ()"},{"location":"TestCode/main_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"TestCode/main_8cpp/#variable-fl_high_frequency","title":"variable fl_high_frequency","text":"<pre><code>float fl_high_frequency;\n</code></pre>"},{"location":"TestCode/main_8cpp/#variable-fl_low_frequency","title":"variable fl_low_frequency","text":"<pre><code>float fl_low_frequency;\n</code></pre>"},{"location":"TestCode/main_8cpp/#variable-i_pin","title":"variable i_pin","text":"<pre><code>const int i_pin;\n</code></pre>"},{"location":"TestCode/main_8cpp/#variable-u32_duration_high","title":"variable u32_duration_high","text":"<pre><code>volatile uint32_t u32_duration_high;\n</code></pre>"},{"location":"TestCode/main_8cpp/#variable-u32_duration_low","title":"variable u32_duration_low","text":"<pre><code>volatile uint32_t u32_duration_low;\n</code></pre>"},{"location":"TestCode/main_8cpp/#variable-u32_start_time_high","title":"variable u32_start_time_high","text":"<pre><code>volatile uint32_t u32_start_time_high;\n</code></pre>"},{"location":"TestCode/main_8cpp/#variable-u32_start_time_low","title":"variable u32_start_time_low","text":"<pre><code>volatile uint32_t u32_start_time_low;\n</code></pre>"},{"location":"TestCode/main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"TestCode/main_8cpp/#function-pin_change","title":"function Pin_Change","text":"<p>This function is responsible for handling pin state changes. <pre><code>void Pin_Change () \n</code></pre></p> <p>\\</p> <p>This function reads the state of a digital pin and records the timing information for transitions between HIGH and LOW states. It calculates the duration of the HIGH and LOW states and updates the corresponding variables accordingly. </p>"},{"location":"TestCode/main_8cpp/#function-loop","title":"function loop","text":"<pre><code>void loop () \n</code></pre>"},{"location":"TestCode/main_8cpp/#function-setup","title":"function setup","text":"<pre><code>void setup () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_OUT_Pruefgeraet/src/main.cpp</code></p>"},{"location":"TestCode/main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; COD_ENG_OUT_Pruefgeraet &gt; src &gt; main.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;Arduino.h&gt;\n\nconst int i_pin = 2; \nvolatile uint32_t u32_start_time_high = 0;\nvolatile uint32_t u32_duration_high = 0; \nvolatile uint32_t u32_start_time_low = 0; \nvolatile uint32_t u32_duration_low = 0; \nfloat fl_high_frequency = 0.0; \nfloat fl_low_frequency = 0.0; \n\nvoid Pin_Change();\n\nvoid setup() {\n  pinMode(i_pin, INPUT);\n  attachInterrupt(digitalPinToInterrupt(i_pin), Pin_Change, CHANGE);\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  if (u32_duration_high &gt; 0) {\n    fl_high_frequency = 1000000.0 / u32_duration_high; // Calculate frequency for the high state in Hertz\n    Serial.print(\"Duration of Pin High: \");\n    Serial.print(u32_duration_high);\n    Serial.print(\" microseconds, Frequency: \");\n    Serial.print(fl_high_frequency, 3); // Display frequency with 3 decimal places\n    Serial.println(\" Hz\");\n    u32_duration_high = 0; // Reset duration for the next measurement\n  }\n\n  if (u32_duration_low &gt; 0) {\n    fl_low_frequency = 1000000.0 / u32_duration_low; // Calculate frequency for the low state in Hertz\n    Serial.print(\"Duration of Pin Low: \");\n    Serial.print(u32_duration_low);\n    Serial.print(\" microseconds, Frequency: \");\n    Serial.print(fl_low_frequency, 3); // Display frequency with 3 decimal places\n    Serial.println(\" Hz\");\n    u32_duration_low = 0; // Reset duration for the next measurement\n  }\n}\n\nvoid Pin_Change() {\n  int state = digitalRead(i_pin);\n  unsigned long currentTime = micros();\n\n  if (state == HIGH) {\n    u32_start_time_high = currentTime; // Save current time for the beginning of the high state\n    if (u32_duration_low == 0) {\n      u32_duration_low = currentTime - u32_start_time_low; // Calculate elapsed time for low state\n    }\n  } else {\n    u32_start_time_low = currentTime; // Save current time for the beginning of the low state\n    if (u32_duration_high == 0) {\n      u32_duration_high = currentTime - u32_start_time_high; // Calculate elapsed time for high state\n    }\n  }\n}\n</code></pre>"},{"location":"TestCode/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"TestCode/classes/","title":"Class Index","text":""},{"location":"TestCode/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p>"},{"location":"TestCode/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"TestCode/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"TestCode/class_members/","title":"Class Members","text":"<p>Nothing related to Class Members found.</p>"},{"location":"TestCode/class_member_functions/","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"TestCode/class_member_variables/","title":"Class Member Variables","text":"<p>Nothing related to Class Member Variables found.</p>"},{"location":"TestCode/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"TestCode/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"TestCode/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"TestCode/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"TestCode/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"TestCode/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"TestCode/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"TestCode/functions/","title":"Functions","text":""},{"location":"TestCode/functions/#l","title":"l","text":"<ul> <li>loop (main.cpp)</li> </ul>"},{"location":"TestCode/functions/#p","title":"p","text":"<ul> <li>Pin_Change (main.cpp)</li> </ul>"},{"location":"TestCode/functions/#s","title":"s","text":"<ul> <li>setup (main.cpp)</li> </ul>"},{"location":"TestCode/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"TestCode/variables/","title":"Variables","text":""},{"location":"TestCode/variables/#f","title":"f","text":"<ul> <li>fl_high_frequency (main.cpp)</li> <li>fl_low_frequency (main.cpp)</li> </ul>"},{"location":"TestCode/variables/#i","title":"i","text":"<ul> <li>i_pin (main.cpp)</li> </ul>"},{"location":"TestCode/variables/#u","title":"u","text":"<ul> <li>u32_duration_high (main.cpp)</li> <li>u32_duration_low (main.cpp)</li> <li>u32_start_time_high (main.cpp)</li> <li>u32_start_time_low (main.cpp)</li> </ul>"},{"location":"TestCode/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"Calculations/annotated/","title":"Class List","text":"<p>No classes, structs, unions or interfaces found.</p>"},{"location":"Calculations/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir Engineering <ul> <li>dir COD_ENG_CALC_calculators <ul> <li>file color_calculator.cpp This file contains the implementation of the color calculator. </li> </ul> </li> </ul> </li> </ul>"},{"location":"Calculations/dir_6774b76becf5c1eba00b38f86dafd5a0/","title":"Dir Engineering","text":"<p>FileList &gt; Engineering</p>"},{"location":"Calculations/dir_6774b76becf5c1eba00b38f86dafd5a0/#directories","title":"Directories","text":"Type Name dir COD_ENG_CALC_calculators <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/</code></p>"},{"location":"Calculations/dir_17970de91eb624507a74aaad367e0c70/","title":"Dir COD_ENG_CALC_calculators","text":"<p>FileList &gt; COD_ENG_CALC_calculators</p>"},{"location":"Calculations/dir_17970de91eb624507a74aaad367e0c70/#files","title":"Files","text":"Type Name file color_calculator.cpp This file contains the implementation of the color calculator. <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_CALC_calculators/</code></p>"},{"location":"Calculations/color__calculator_8cpp/","title":"File color_calculator.cpp","text":"<p>FileList &gt; COD_ENG_CALC_calculators &gt; color_calculator.cpp</p> <p>Go to the source code of this file</p> <p>This file contains the implementation of the color calculator. More...</p> <ul> <li><code>#include &lt;inttypes.h&gt;</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> </ul>"},{"location":"Calculations/color__calculator_8cpp/#public-functions","title":"Public Functions","text":"Type Name uint16_t getColor (uint8_t r, uint8_t g, uint8_t b) This function calculates the 16 bit color value from the given RGB values. int main ()"},{"location":"Calculations/color__calculator_8cpp/#detailed-description","title":"Detailed Description","text":"<p>The color calculator is used to calculate the 16 bit color value from RGB values. The 16 Bit intgeger can then be used for the Matrix library directly. This reduces the startuptime of the arduino compared to setting the RGB values in the Setup routine.</p> <p>The color calculator expects the Values in RGB order. Values can reach from 0 to 255. Be careful as You will NOT be told when input is invalid.</p> <p>compile with: <code>gcc  color_calculator.cpp -o color_calculator</code></p> <p>Run with: <code>./color_calculator</code> </p>"},{"location":"Calculations/color__calculator_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Calculations/color__calculator_8cpp/#function-getcolor","title":"function getColor","text":"<p>This function calculates the 16 bit color value from the given RGB values. <pre><code>uint16_t getColor (\n    uint8_t r,\n    uint8_t g,\n    uint8_t b\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>r</code> The red value of the color. </li> <li><code>g</code> The green value of the color. </li> <li><code>b</code> The blue value of the color. </li> </ul> <p>Returns:</p> <p>The 16 bit color value to be used for the LED matrix. </p>"},{"location":"Calculations/color__calculator_8cpp/#function-main","title":"function main","text":"<pre><code>int main () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Arduino_DHBW_Spiel/Arduino_DHBW_Spiel/Engineering/COD_ENG_CALC_calculators/color_calculator.cpp</code></p>"},{"location":"Calculations/color__calculator_8cpp_source/","title":"File color_calculator.cpp","text":"<p>File List &gt; COD_ENG_CALC_calculators &gt; color_calculator.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;inttypes.h&gt;\n#include &lt;stdio.h&gt;\n\nuint16_t getColor(uint8_t r, uint8_t g, uint8_t b) {\n  return ((uint16_t)(r &amp; 0xF8) &lt;&lt; 8) | ((uint16_t)(g &amp; 0xFC) &lt;&lt; 3) | (b &gt;&gt; 3);\n}\n\nint main() {\n  int inputr = 0;\n  int inputg = 0;\n  int inputb = 0;\n  scanf(\"%i\", &amp;inputr);\n  scanf(\"%i\", &amp;inputg);\n  scanf(\"%i\", &amp;inputb);\n  uint16_t i = getColor(inputr, inputg, inputb);\n  printf(\"0x%02x\\n\", i);\n  return 0;\n}\n</code></pre>"},{"location":"Calculations/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"Calculations/classes/","title":"Class Index","text":""},{"location":"Calculations/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p>"},{"location":"Calculations/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Calculations/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Calculations/class_members/","title":"Class Members","text":"<p>Nothing related to Class Members found.</p>"},{"location":"Calculations/class_member_functions/","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"Calculations/class_member_variables/","title":"Class Member Variables","text":"<p>Nothing related to Class Member Variables found.</p>"},{"location":"Calculations/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Calculations/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Calculations/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"Calculations/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"Calculations/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"Calculations/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"Calculations/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"Calculations/functions/","title":"Functions","text":""},{"location":"Calculations/functions/#g","title":"g","text":"<ul> <li>getColor (color_calculator.cpp)</li> </ul>"},{"location":"Calculations/functions/#m","title":"m","text":"<ul> <li>main (color_calculator.cpp)</li> </ul>"},{"location":"Calculations/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"Calculations/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"Calculations/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}